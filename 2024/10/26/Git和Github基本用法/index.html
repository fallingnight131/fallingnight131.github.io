<!DOCTYPE html><html lang="zh-cn" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Git和Github基本用法 | 落夜的博客</title><link rel="icon" type="image/x-icon" href="/icons/rhodes.ico"><link rel="preload" as="font" crossorigin="anonymous" href="/font/Bender.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/font/BenderLight.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/font/JetBrainsMono-Regular.woff2"><link rel="stylesheet" href="/css/arknights.css"><style>@font-face {
  font-family: Bender;
  src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
  font-family: BenderLight;
  src: local('BenderLight'), url("/font/BenderLight.ttf");
}
@font-face {
  font-family: 'JetBrains Mono';
  src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}
</style><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 - $1 行","copy":"复制"}}</script><link type="text/css" rel="stylesheet" href="/lib/encrypt/hbe.style.css"><script src="//unpkg.com/mermaid@10.5.0/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.woff2") format('woff2');
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
 --dark-background: url('/img/bg.png');
 --light-background: url('/img/bk.png');
 --theme-encrypt-confirm: '确认'
}</style><script defer src="/js/arknights.js"></script><script defer src="/js/search.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script async src="//unpkg.com/valine/dist/Valine.min.js"></script><script defer type="module">import mermaid from '//unpkg.com/mermaid@10.5.0/dist/mermaid.esm.mjs';
window.mermaid = mermaid;
code.paintMermaid();
</script><script async src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script async src="/lib/encrypt/hbe.js"></script><script async src="/js/pjax.js"></script><script class="pjax-js">reset= () => {new Valine({
 el: '#valine'
 , appId: 'lzRgHUERfqoIJzb0bPUyfePx-MdYXbMMI'
 , appKey: 'cZsD5NopudwTaPNmqufIIG9P', serverURLs: 'https://lzrghuer.api.lncldglobal.com' , placeholder: '此条评论委托企鹅物流发送'
 , path: window.location.pathname
 , avatar: 'gravatar'
 , avatar_cdn: 'https://dn-qiniu-avatar.qbox.me/avatar/'
});document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js','data-pjax','.busuanzi'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);document.addEventListener('pjax:success', _ => bszCaller.fetch(
 "//busuanzi.ibruce.info/busuanzi?jsonpCallback=BusuanziCallback", a => {
  bszTag.texts(a),
  bszTag.shows()
}));reset()})</script><script class="pjax-js">reset= () => {new Valine({
 el: '#valine'
 , appId: 'lzRgHUERfqoIJzb0bPUyfePx-MdYXbMMI'
 , appKey: 'cZsD5NopudwTaPNmqufIIG9P', serverURLs: 'https://lzrghuer.api.lncldglobal.com' , placeholder: '此条评论委托企鹅物流发送'
 , path: window.location.pathname
 , avatar: 'gravatar'
 , avatar_cdn: 'https://dn-qiniu-avatar.qbox.me/avatar/'
});document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup" tabindex="0"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">首页</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">归档</span></a></li><li class="navItem"><a class="navBlock" href="/about/"><span class="navItemTitle">关于</span></a></li><li class="navItem"><a class="navBlock" href="/links-portals/"><span class="navItemTitle">星门</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>Git和Github基本用法</h1><div id="post-info"><span>文章发布时间: <div class="control"><time datetime="2024-10-26T04:59:54.000Z" id="date"> 2024-10-26</time></div></span><br><span>最后更新时间: <div class="control"><time datetime="2025-03-21T07:31:48.097Z" id="updated"> 2025-03-21</time></div></span><br><span>文章总字数: <div class="control">8k</div></span><br><span>预计阅读时间: <div class="control">29 分钟</div></span><br><span id="busuanzi_container_page_pv">页面浏览: <span class="control" id="busuanzi_value_page_pv">加载中...</span></span></div></div><hr><div id="post-content"><p></p>
<h1 id="git和github的关系和区别"><a href="#git和github的关系和区别" class="headerlink" title="git和github的关系和区别"></a><a target="_blank" rel="noopener" href="https://git-scm.com/">git</a>和<a target="_blank" rel="noopener" href="https://github.com/">github</a>的关系和区别</h1><h2 id="git"><a href="#git" class="headerlink" title="git"></a><a target="_blank" rel="noopener" href="https://git-scm.com/">git</a></h2><p>说到git，很多初学者的第一印象是github，好像git的用处就是从github仓库clone项目，或者也可以把自己的项目上传到github，但是为什么要上传，也不是很清楚。</p>
<p>其实，git作为一个分布式版本控制系统，是一个命令行工具，它最根本的功能是用于在本地管理和跟踪文件的更改历史，或者用更好理解的说法，git的基础功能是“存档”。</p>
<p>在打游戏的时候，你会时不时存个档，这样干了什么傻事以后还可以回档，比如你不小心销毁了一件很重要的装备以后，你可以通过回档撤销你干的傻事。同时，有些游戏还支持备份存档，也就是说你可以在这个存档的基础上，复制一个平行的存档，新存档生成的时候和原来的存档游戏进度相同，但是当新存档生成以后，就和原来的存档互不影响了，你可以在备份的存档里面干各种原来不敢在主存档干的事，就算把装备都融了，屋子都炸了也不用在意。有些游戏还支持存档互通，你在备份存档里面打败了新的boss，有了更好的装备，还可以送回主存档，加快主存档的进度。这样一来，坏事影响不了主存档，好事却可以。而存档文件通常不大，100多个G的游戏玩了几个月的存档文件可能还不到100M。有了存档的机制，你玩游戏的时候会更加放松工具自在。</p>
<p>git差不多就是这么一个玩意，git的本地仓库干的就是存档的活。有时候你会担心把原本良好的代码改坏而蹑手蹑脚，亦或者你有时突然感觉之前的代码更好。如果你每次改代码前都留一个备份，那你的文件夹会看起来很乱，而且每留一版备份，就会多一用倍的存储空间，十分不方便。而git所包含的版本控制功能就很好的解决解决了这个问题。git commit对应了游戏中的手动存档;git reset、git revert、git restore等命令对应了游戏中的回档;git branch对应了游戏中备份了一个平行存档;git checkout对应了切换存档;git merge对应了将其他备份存档的装备送到主存档。。。。。。有了这个类别，git的意义也就很好理解了。</p>
<h2 id="github"><a href="#github" class="headerlink" title="github"></a><a target="_blank" rel="noopener" href="https://github.com/">github</a></h2><p>git并不依赖github，git甚至不联网都能用，git是单人开发的时候也可以使用的工具，便于存档回档而存在。而github却依赖git，github是一个代码托管平台，它利用git来进行版本控制，允许你将本地的git仓库推送到远程，并与他人共享代码。除了github以外，国内还有类似gitee这样功能相似的平台，它们的基本功能是相似的。</p>
<p>除去让别人看得到自己的代码(开源)以外，github最核心的功能便是多人开发。对于一个多人完成的项目而言，每个成员闭门造车肯定会效率低下。github提供了一个多人协作的良好平台。在一个项目建立的时候，技术负责人创建一个github仓库，创建一个main分支,main分支是门面，是后续发布的根本，所以main分支必须是纯净的，所以在main的基础上创建一个dev分支，dev(develop)分支负责开发，后续的改动都在dev分支上面进行。团队的不同人负责不同的事情，比如张三负责增加菜单，王五负责增加背景音乐，那他们就分别在dev的基础上再分别开一个feature/menu和feature/music分支并在这两个分支上面做开发和改动，当开发的差不多了，就将这两个分支合并到dev分支，当开发到了一个阶段(比如实现了基本功能)，就由负责人在dev分支的基础是建立一个release分支，在这个分支上做最后的调试和bug修复，最后当一切都没有问题了，再由负责人将release合并到main分支。这样一来，main分支的代码始终是纯净的，稳定的，也方便了后续的发布和部署。</p>
<h1 id="git命令"><a href="#git命令" class="headerlink" title="git命令"></a>git命令</h1><h2 id="配置类命令"><a href="#配置类命令" class="headerlink" title="配置类命令"></a>配置类命令</h2><h3 id="配置全局用户名"><a href="#配置全局用户名" class="headerlink" title="配置全局用户名"></a>配置全局用户名</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;Your Name&quot;</span><br></code></pre></td></tr></table></figure>
<h3 id="配置全局邮箱"><a href="#配置全局邮箱" class="headerlink" title="配置全局邮箱"></a>配置全局邮箱</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.email <span class="hljs-string">&quot;you@example.com&quot;</span><br></code></pre></td></tr></table></figure>
<p>配置全局用户名和邮箱有助于多人开发时让别人知道相关提交源自于谁</p>
<h3 id="设置默认的文本编辑器"><a href="#设置默认的文本编辑器" class="headerlink" title="设置默认的文本编辑器"></a>设置默认的文本编辑器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global core.editor <span class="hljs-string">&quot;code --wait&quot;</span>   //vscode<br>git config --global core.editor <span class="hljs-string">&quot;vim&quot;</span>           //vim<br>git config --global core.editor <span class="hljs-string">&quot;subl -n -w&quot;</span>    //sublime text<br>git config --global core.editor <span class="hljs-string">&quot;atom --wait&quot;</span>   //atom<br>git config --global core.editor <span class="hljs-string">&quot;clion --wait&quot;</span>  //clion<br>git config --global core.editor <span class="hljs-string">&quot;charm -w&quot;</span>      //pycharm<br></code></pre></td></tr></table></figure>
<p>在进行commit操作以后，如果没有增加提交描述，git会强制打开一个默认文本编辑器让你编辑提交描述(一般默认是vim)，对于不熟悉vim的人而言，这会十分麻烦，设置一个趁手的默认文本编辑器会让编辑过程方便一些。</p>
<h2 id="本地仓库命令"><a href="#本地仓库命令" class="headerlink" title="本地仓库命令"></a>本地仓库命令</h2><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p>在项目文件夹根目录输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init<br></code></pre></td></tr></table></figure><br>初始化仓库以后，在根目录会出现一个名为.git的隐藏文件夹(要在文件资源管理器-&gt;查看-&gt;显示中勾选隐藏的项目才能看到)，就是由这个文件夹记录git仓库的各种信息和各种分支、提交。删掉这个文件夹，也就删掉了本地仓库，这时就又要通过git init重新创建本地仓库了。</p>
<h3 id="更改缓存"><a href="#更改缓存" class="headerlink" title="更改缓存"></a>更改缓存</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add &lt;file&gt;              //将单个文件添加到暂存区。<br>git add .                   //添加当前目录下的所有文件到暂存区。<br>git reset &lt;file&gt;            //清理特定文件的缓存<br>git reset                   //清理所有暂存的更改<br>git restore --staged &lt;file&gt; //效果和git reset &lt;file&gt;类似<br>git restore --staged .      //效果和git reset 类似<br>git reset --hard            //清除未提交的所有更改（包括暂存区和工作区）<br>git <span class="hljs-built_in">rm</span> --cached &lt;file&gt;      //删除暂存区中特定文件的缓存，并且让Git停止追踪它<br>git <span class="hljs-built_in">rm</span> -r --cached .        //删除暂存区中所有文件的缓存，并且让Git停止追踪它们<br></code></pre></td></tr></table></figure>
<p>在提交版本(存档)前需要提交的内容放入缓存，为后续提交指定范围。<br>如果要查看缓存的状态，我们可以使用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git status<br></code></pre></td></tr></table></figure><br>来查看哪些文件被缓存，哪些被追踪的文件没有被缓存<br>如果不出意外，你会觉得一个一个添加缓存很慢，我们当然希望能用一个命令就把该缓存的全都缓存、该删除缓存的全都删除了。但是直接用git add .又不合理，因为比如.venv(虚拟环境)、build这样的文件是不应该被git追踪并缓存的。因为这些文件很大、而且他们的变化是编译或者安装库的结果，不是我们应该关系的，也不是应该由我们手动更改的。我们需要一种方法，将这些文件排除在版本控制之外。<br>git提供了一种方法将文件或者文件夹排除在版本控制之外————.gitignore<br>首先，在要排除的文件或者文件夹所在的那一级目录新建一个文件，取名为.gitignore 。注意前面的点不要漏掉。<br>随后，将要排除的文件夹或者文件的名字填入其中，一行一个，再保存一下，这些被填入其中的文件和文件夹就被排除在版本控制之外了。<br><img src="https://raw.githubusercontent.com/fallingnight131/media_resource/blog/image/20250308022313360.png" alt><br>有些时候.gitignore可能不生效，可以试试删了重建.gitignore ，在输入以下命令让Git停止追踪要忽略的内容<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">rm</span> -r --cached .<br>git add .<br></code></pre></td></tr></table></figure><br>当确定.gitignore生效以后，此后每次提交前更改缓存就只要执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .<br></code></pre></td></tr></table></figure><br>就行了。</p>
<h3 id="提交版本"><a href="#提交版本" class="headerlink" title="提交版本"></a>提交版本</h3><p>提交版本相对应给游戏存档，是git最核心的功能，版本提交命令如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit                      //不带提交描述<br>git commit -m <span class="hljs-string">&quot;commit message&quot;</span>  //带提交描述<br></code></pre></td></tr></table></figure><br>对应git，每次commit都是必须携带提交描述的，而且不能用空字符串代替，对于第一种命令，git会打开默认文本编辑器让你编辑提交信息，不会用vim记得按照本文前面的内容修改默认文本编辑器。<br><img src="https://raw.githubusercontent.com/fallingnight131/media_resource/blog/image/20250308022405745.png" alt></p>
<p><img src="https://raw.githubusercontent.com/fallingnight131/media_resource/blog/image/20250308022520450.png" alt><br>在第一行的空白处填上提交描述，保存以后关闭文本编辑器，提交就完成了。</p>
<p>对于第二种命令，直接将描述写在引号里面就行，不需要再去编辑文本编辑器。</p>
<p>如果需要查看之前提交过的版本，可以通过以下命令查看提交日志<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span>             //打印日志完整信息<br>git <span class="hljs-built_in">log</span> --oneline   //打印日志简略信息，每次提交占一行<br></code></pre></td></tr></table></figure></p>
<p>如果想要回到之前某一次提交之后，查看那次提交的<a target="_blank" rel="noopener" href="https://vscode.github.net.cn/docs/editor/workspaces#google_vignette">工作区</a>状态，可以通过命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout &lt;commit-hash&gt;<br></code></pre></td></tr></table></figure><br>回到那次提交后的状态。</p>
<p><commit-hash>是那次的哈希值，git会为每次提交生成独一无二的哈希值，哈希值可以通过查看提交日志知晓。<br>这个命令可以改变<a target="_blank" rel="noopener" href="https://juejin.cn/post/7103746773335687176">HEAD指针</a>，但是这种状态类似只读状态，你在工作区做的任何更改都不会被保留。<br>查看完以后，可以通过<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -<br></code></pre></td></tr></table></figure><br>返回最后一次提交的状态</commit-hash></p>
<h3 id="版本回滚"><a href="#版本回滚" class="headerlink" title="版本回滚"></a>版本回滚</h3><p>版本回滚相对应游戏里的回档，可以通过以下几种命令进行版本回滚。</p>
<h4 id="git-reset命令"><a href="#git-reset命令" class="headerlink" title="git reset命令"></a>git reset命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --soft &lt;commit-hash&gt;       //仅重置 HEAD，不影响暂存区和工作区<br>git reset --mixed &lt;commit-hash&gt;      //重置 HEAD 和暂存区，保留工作区更改（默认）<br>git reset --hard &lt;commit-hash&gt;       //重置 HEAD、暂存区和工作区，彻底清除后续所有更改<br></code></pre></td></tr></table></figure>
<p>使用soft后缀的话，只会将那次提交之后的所有提交去除，但是工作区和缓存区都不会改变，如果你觉得某次提交之后的所有提交都没有什么实际意义，你希望自己的提交历史看起来清爽一点，但又感觉现在的工作区还不错，不想改动工作区，那不妨试试这个命令。<br>mixed后缀是git reset的默认方法，也就是如果你不加—后缀，就会默认带了—mixed，和soft的区别是，mixed还重置了缓存区，便于你进行手动恢复文件之类的操作(虽然并不是很好用)<br>如果希望完全回档，推荐使用hard后缀，hard后缀可以完全重置到那次提交以后的HEAD、暂存区和工作区，是最符合“回档”期望的命令，如果觉得某次提交之后的代码越写越屎，可以直接用这个命令穿越回过去(bushi)<br>直接撤回最近一次提交可以用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --hard HEAD~1<br></code></pre></td></tr></table></figure><br>同理，如果你希望撤回最近n次提交，可以使用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --hard HEAD~n<br></code></pre></td></tr></table></figure><br>如果想直接回到最近一次提交，清除未提交的所有更改（包括暂存区和工作区），可以使用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --hard<br></code></pre></td></tr></table></figure></p>
<h4 id="git-revert命令"><a href="#git-revert命令" class="headerlink" title="git revert命令"></a>git revert命令</h4><p>git reset简单粗暴，但也有其弊端，git reset会完全丢弃回滚的那次提交以后的所有提交，也就是说你回档以后又后悔了，那你就没的后悔了。<br>而且在多人开发中，reset如果回滚到了某次合并分支的结点之前，也会因为两边历史不同而造成冲突，所以在多人开发中，reset只能回退到最近一次合并或创建分支的结点之后，有一定局限。<br>如果要符合多人开发规范，需要使用git revert命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git revert &lt;commit-hash&gt;     //撤销某次提交<br>git revert HEAD              //撤销最新的提交<br>git revert HEAD~3..HEAD      //撤销前3次提交，但是分三次提交<br>git revert -n HEAD~3..HEAD   //撤销前3次提交，但是一次性提交<br></code></pre></td></tr></table></figure><br>注意，-n是代表不提交模式，三次撤销完了也不会提交，需要<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -m <span class="hljs-string">&quot;Reverted last 3 commits&quot;</span><br></code></pre></td></tr></table></figure><br>手动提交<br>能撤销前三次，说明也能撤销前n次，把3改成其他数字就行。<br>和reset不一样，reset是撤销到某次提交之后，而revert则是撤销某次提交，没有之后。记得不要撤销过头。<br>git revert不会移除任何提交信息，而是在当前分支上创建一个新的提交，这个提交的内容会“反向应用”指定的更改，也就是说，使用git revert以后，提交历史反而会变多。<br>git revert和git reset相比不会在多人开发中产生因为历史不同而生的冲突和错误。<br>git revert可以撤销中间几次的提交，比如<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git revert -n HEAD~7..HEAD~4<br></code></pre></td></tr></table></figure><br>是撤销倒数第5次和倒数第6次提交。记得，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git revert -n HEAD~x..HEAD~y<br></code></pre></td></tr></table></figure><br>撤销的是倒数第y+1到倒数第x-1次提交，不是倒数y到x次提交！很反常识对吗，反正找个理由说服自己就行。。。。。。<br>在git revert的时候，特别是撤销中间几次提交的时候，很容易发送冲突，这时候git会打开默认文本编辑器让你解决冲突，按照预期取舍就行，实在不知道怎么搞就点击接受组合。<br>在git revert的过程中，当你处于一个操作中，你可以通过下述命令选择继续、放弃或退出该操作。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git revert --<span class="hljs-built_in">continue</span>   //如果你已经解决了冲突或完成了必要的更改，可以继续 revert 操作<br>git revert --abort      //放弃当前的 revert 操作，并将仓库恢复到 revert 操作开始之前的状态。<br>git revert --quit       //退出当前的 revert 操作，但保留已经应用的更改。<br></code></pre></td></tr></table></figure></p>
<h4 id="git-restore命令"><a href="#git-restore命令" class="headerlink" title="git restore命令"></a>git restore命令</h4><p>如果你觉得git revert命令太复杂了，到是还有一种更加简单，而且还不破坏提交历史的方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git restore --<span class="hljs-built_in">source</span>=&lt;commit-hash&gt; --staged --worktree .<br>git commit -m <span class="hljs-string">&quot;将版本回滚到&lt;commit-hash&gt;状态&quot;</span><br></code></pre></td></tr></table></figure><br>这个命令并不会影响提交历史，而是从指定的提交中恢复文件到当前工作目录和暂存区，这意味着当前工作目录中的文件将被替换为指定提交中的版本。<br>这时候再手动commit一下，就可以将那个版本的工作区作为一个新的提交。<br>这样一来，也可以等效达成”回档”的目的，而且因为是在原基础上新建提交，所以并不会破坏之前的提交。<br>不过相比于git revert，git restore命令的跨度太大了，因为是恢复工作区和缓存，而不是回滚，虽然这种方法在多人开发中不会造成冲突，但其规范性还是不如git revert。</p>
<h3 id="修改版本信息"><a href="#修改版本信息" class="headerlink" title="修改版本信息"></a>修改版本信息</h3><p>有时你可能觉得之前某次提交不好，但是又不希望弄没之后的提交，这时候你可能需要通过rebase来修改个别提交<br>首先启动启动交互式 rebase<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git rebase -i HEAD~4<br></code></pre></td></tr></table></figure><br>-i 用于启用交互模式，使用命令以后，git会打开默认文本编辑器进行交互编辑<br><img src="https://raw.githubusercontent.com/fallingnight131/media_resource/blog/image/20250308022617771.png" alt><br>中间那个是每次提交的哈希值，右边那个是每次提交的描述(我偷懒随便写的)<br>HEAD后面填了4，所以显示了最近4次提交，用更大的数字可以查看到跟之前的提交<br>之后我们要根据需求更改pick为其他命令<br><blockquote><p>常用命令<br>pick：保留该提交。相当于“选择”该提交并按原样应用到新的历史记录中。</p>
<p>edit：标记该提交需要修改，Git 会在这个提交暂停，允许你进行修改、补充内容或更改提交信息。修改完成后继续 rebase。</p>
<p>squash（简写：s）：将当前提交与前一个提交合并，并且会合并两者的提交信息。适用于整理多个小的提交，将它们合并成一个较大的提交。</p>
<p>fixup（简写：f）：类似于 squash，将当前提交与前一个提交合并，但不会保留当前提交的信息。这在仅想保留前一个提交信息的情况下非常有用。</p>
<p>reword：保留该提交，但允许修改其提交信息。</p>
<p>drop：删除该提交，从历史记录中移除它。</p>
</blockquote><br>值得注意的是，reword只能修改提交描述，edit还可以修改那次提交的操作信息，比如你可以在文件里面加点什么删点什么，不过不出意外会出点冲突，这样就又要解决冲突了。<br>比如我们想修改4444那次提交，我们把4444那次提交前面的pick改成edit<br><img src="https://raw.githubusercontent.com/fallingnight131/media_resource/blog/image/20250308022711908.png" alt><br>之后我们保存并关闭编辑文件，就临时进入了那次提交的编辑状态(最近的不再是ddd，而是4444)<br><img src="https://raw.githubusercontent.com/fallingnight131/media_resource/blog/image/20250308022745612.png" alt><br>随后我们修改完相应的文件，用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .<br></code></pre></td></tr></table></figure><br>添加缓存，解决完冲突再用命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git rebase --<span class="hljs-built_in">continue</span><br></code></pre></td></tr></table></figure><br>进入文本编辑器编辑提交信息，再保存关闭文本编辑器，修改就完成了。<br><img src="https://raw.githubusercontent.com/fallingnight131/media_resource/blog/image/20250308022819349.png" alt><br>最近的一次提交也变回了ddd，而4444那次提交中则增加了你新编辑的那些操作。</p>
<p>和revert一样，rebase也不止有continue后缀<br>在revert过程中解决了冲突或其他更改，可以用相同命令选择继续、放弃或退出该操作<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git rebase --<span class="hljs-built_in">continue</span>   //如果你已经解决了冲突或完成了必要的更改，可以继续 rebase 操作<br>git rebase --abort      //放弃当前的 rebase 操作，并将仓库恢复到 rebase 操作开始之前的状态。<br>git rebase --quit       //退出当前的 rebase 操作，但保留已经应用的更改。<br></code></pre></td></tr></table></figure></p>
<h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p>分支相当于游戏里的备份存档，在git中同样有着十分重要的功能。</p>
<h4 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h4><p>使用命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch &lt;branch_name&gt;<br></code></pre></td></tr></table></figure><br>你在哪个分支上创建分支，就是在哪个分支的基础上创建分支。。。。。。额，这可能不像是人话。<br>或者说，比如你在main这个分支上输入了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch dev<br></code></pre></td></tr></table></figure><br>的命令，那就是在main这个分支的基础上，分出了dev这个分支，dev将会继承main的所有文件信息和提交历史，同时后续对两者编辑又互不影响。</p>
<h4 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h4><p>使用命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout &lt;branch_name&gt;<br></code></pre></td></tr></table></figure><br>可以切换到指定分支。<br>切换到不同分支以后，工作区和提交历史都会变成相应分支的状态。</p>
<p>对应创建分支，如果希望快一点，直接创建并切换到新分支，也可以用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -b &lt;branch_name&gt;<br></code></pre></td></tr></table></figure><br>直接一步到位。</p>
<h4 id="列出本地分支"><a href="#列出本地分支" class="headerlink" title="列出本地分支"></a>列出本地分支</h4><p>使用命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch<br></code></pre></td></tr></table></figure><br>可以列出本地分支的信息。比如：<br><img src="https://raw.githubusercontent.com/fallingnight131/media_resource/blog/image/20250308022846797.png" alt><br>说明本地仓库有两个分支，分别是main和dev，其中main前面有星号意味着目前切换到的分支是main。</p>
<h4 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h4><p>使用命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -d &lt;branch_name&gt;<br></code></pre></td></tr></table></figure><br>可以删除本地分支</p>
<h4 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h4><p>当开发到一点程度的时候，要将分支的内容合并到主干上，有两种方法可以合并分支</p>
<h5 id="用merge合并"><a href="#用merge合并" class="headerlink" title="用merge合并"></a>用merge合并</h5><p>一般情况下大多采用merge合并<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git merge &lt;branch_name&gt;<br></code></pre></td></tr></table></figure><br>比如要将dev合并到main，那就先切换到main分支，再执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git merge dev<br></code></pre></td></tr></table></figure><br>这样一来，dev就被合并到了main上<br>但经过这样的合并，main的提交历史就不一定是直线的了。比如我们在dev分支创建以后，先在dev上进行了三次提交，后来又在main上进行了一次提交，那通过merge合并以后，提交历史会变成这样：<br><img src="https://raw.githubusercontent.com/fallingnight131/media_resource/blog/image/20250308022917285.png" alt><br>如果你有某种洁癖，不能忍受非直线的历史，可以尝试后面的方法。</p>
<h5 id="用rebase合并"><a href="#用rebase合并" class="headerlink" title="用rebase合并"></a>用rebase合并</h5><p>rebase不仅可以修改提交信息，还可以用来合并分支。<br>在和上面相同的情况下，通过<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git rebase dev<br></code></pre></td></tr></table></figure><br>命令达到的效果是这样的：<br><img src="https://raw.githubusercontent.com/fallingnight131/media_resource/blog/image/20250308022945990.png" alt><br>合并以后的提交历史依旧是直线，这样看起来更加干净，当然，如果用git merge也是完全没有问题的。</p>
<h3 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h3><p>当开发到了一个具有里程意义的时候，需要发布版本，发布前需要增加标签，为发布做准备。</p>
<h4 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git tag -a tag_name commit_hash -m <span class="hljs-string">&quot;Tag message&quot;</span><br></code></pre></td></tr></table></figure>
<p>-a 指定标签为附注标签。<br>-m 允许添加一个标签说明信息 “Release version 1.0”。<br>commit_hash是标签对应提交版本的哈希值<br>例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git tag -a v1.0 9fceb02 -m <span class="hljs-string">&quot;Release version 1.0&quot;</span><br></code></pre></td></tr></table></figure><br>9fceb02也可以换成完整的哈希值</p>
<h4 id="列出所有标签"><a href="#列出所有标签" class="headerlink" title="列出所有标签"></a>列出所有标签</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git tag<br></code></pre></td></tr></table></figure>
<h4 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git tag -d tag_name<br></code></pre></td></tr></table></figure>
<h4 id="查看标签详情"><a href="#查看标签详情" class="headerlink" title="查看标签详情"></a>查看标签详情</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git show tag_name<br></code></pre></td></tr></table></figure>
<h4 id="检出到标签版本"><a href="#检出到标签版本" class="headerlink" title="检出到标签版本"></a>检出到标签版本</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout tag_name<br></code></pre></td></tr></table></figure>
<p>可以通过<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -<br></code></pre></td></tr></table></figure><br>返回原来的分支。</p>
<h2 id="远程仓库命令"><a href="#远程仓库命令" class="headerlink" title="远程仓库命令"></a>远程仓库命令</h2><h3 id="增加远程仓库"><a href="#增加远程仓库" class="headerlink" title="增加远程仓库"></a>增加远程仓库</h3><p>增加远程仓库可以通过命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote add &lt;remote&gt; &lt;remote-URL&gt;<br></code></pre></td></tr></table></figure><br>实现。<br>远程仓库的名称是由自己来取，不一定和github仓库那边一样，远程仓库URL要在github仓库那里获取，就是git clone后面常跟的那串URL。<br>例如可以添加一个名字取为origin的远程仓库<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote add upstream https://github.com/another/repo.git<br></code></pre></td></tr></table></figure><br>远程仓库不一定只能添加一个，一个本地仓库可以添加很多个远程仓库(虽然没有必要)，可以通过切换上游分支来便于拉取和推送。<br>可以通过<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote -v<br></code></pre></td></tr></table></figure><br>查看本地仓库添加了多少远程仓库。</p>
<h3 id="新建远程分支"><a href="#新建远程分支" class="headerlink" title="新建远程分支"></a>新建远程分支</h3><p>先在本地创建一个新分支，再切换到这个分支上(如果已经有分支了也可以不用创建，可以直接切换)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -b &lt;local-branch&gt;<br></code></pre></td></tr></table></figure><br>再将本地新分支推送到远程<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push -u &lt;remote&gt; &lt;remote-branch&gt;<br></code></pre></td></tr></table></figure><br>这样远程就多了一个分支，分支名和<remote-branch>设置的一样。<br>例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -b feature-branch<br>git push -u origin feature-branch<br></code></pre></td></tr></table></figure><br>这里的 -u 会将本地分支与远程分支设置为追踪关系，即将远程分支设置为本地分支的上游，以便将来可以直接使用 git pull 和 git push 来同步。</remote-branch></p>
<h3 id="切换上游分支"><a href="#切换上游分支" class="headerlink" title="切换上游分支"></a>切换上游分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch --set-upstream-to &lt;remote&gt;/&lt;remote-branch&gt; &lt;local-branch&gt;<br></code></pre></td></tr></table></figure>
<p>假设你想将本地的 feature 分支设置为跟踪远程的 origin/feature 分支，可以执行以下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch --set-upstream-to origin/feature feature<br></code></pre></td></tr></table></figure><br>当然，也可以先切换至feature分支，在执行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -u origin/feature<br></code></pre></td></tr></table></figure><br>设置了上游分支以后,之后拉取和推送会简化许多。<br>可以通过<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -vv<br></code></pre></td></tr></table></figure><br>查看每个本地分支对应的上游<br>如果你不清楚远程仓库有哪些分支，可以通过<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git fetch<br>git branch -r<br></code></pre></td></tr></table></figure><br>查看远程仓库所有分支。其中git fetch是获取远程仓库的所有信息(但是不改变工作区和缓存)<br>如果不想要上游分支了，可以先切换到你想取消上游设置的分支，再通过：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch --unset-upstream<br></code></pre></td></tr></table></figure><br>取消上游追踪。</p>
<h3 id="拉取与推送"><a href="#拉取与推送" class="headerlink" title="拉取与推送"></a>拉取与推送</h3><h4 id="拉取远程更新"><a href="#拉取远程更新" class="headerlink" title="拉取远程更新"></a>拉取远程更新</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull &lt;remote&gt; &lt;remote-branch&gt;<br></code></pre></td></tr></table></figure>
<p>例如从 origin 仓库的 main 分支拉取最新的提交到本地的 main 分支：<br>先切换到main分支。再执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull origin main<br></code></pre></td></tr></table></figure><br>命令。<br>git pull可以看作git fetch + git merge 两个命令的结合<br>也就是说，上述命令可以等效成<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git fetch &lt;remote&gt; &lt;remote-branch&gt;<br>git merge &lt;remote&gt; &lt;remote-branch&gt;<br></code></pre></td></tr></table></figure><br>或者<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git fetch  &lt;remote&gt; &lt;remote-branch&gt;<br>git rebase &lt;remote&gt; &lt;remote-branch&gt;<br></code></pre></td></tr></table></figure><br>注意，多人协作时应当尽力避免rebase！<br>如果某个本地分支设置了上游分支，在这个本地分支上可以直接执行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull<br></code></pre></td></tr></table></figure><br>git 会默认从上游分支拉取最新信息。</p>
<h4 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h4><p>在push之前，最好先更新本地分支，避免与远程分支之间有冲突。所以先执行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git fetch &lt;remote&gt; &lt;remote-branch&gt;<br></code></pre></td></tr></table></figure><br>再执行push操作：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push &lt;remote&gt; &lt;remote-branch&gt;<br></code></pre></td></tr></table></figure><br>例如将本地 main 分支的提交推送到 origin 仓库的 main 分支:<br>先切换到main分支。再执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git fetch origin main<br>git push origin main<br></code></pre></td></tr></table></figure><br>命令。<br>如果某个本地分支设置了上游分支，在这个本地分支上可以直接执行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git fetch<br>git push<br></code></pre></td></tr></table></figure><br>git 会默认向上游分支推送最新信息。<br>如果有很多远程仓库，可以通过<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git fetch --prune<br></code></pre></td></tr></table></figure><br>获取所有远程更新并清理无用的远程跟踪分支<br>如果你因为reset或者rebase导致提交历史发生了变化，和远程仓库的历史对不上，那么推送大概率会因为冲突而失败，这时需要一种更强硬的推送命令；<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git fetch<br>git push --force &lt;remote&gt; &lt;branch&gt;<br></code></pre></td></tr></table></figure><br>强制推送会覆盖远程仓库中的分支内容，以匹配本地分支的状态，从而推送成功。<br><div class="tip warning"><i class="i-adm i-warning icon"></i><div class="p"><p>但切记，在多人开发中应当极力避免这个命令出现，这会给其他成员造成极大麻烦！</p>
</div></div> </p>
<h3 id="删除分支-1"><a href="#删除分支-1" class="headerlink" title="删除分支"></a>删除分支</h3><p>当一个分支完成了它的使命以后，通常要在本地和远程将这个分支删去。怎么在本地删除分支在前文写了，在远程仓库删除分支需要执行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push &lt;remote&gt; --delete &lt;remote-branch&gt;<br></code></pre></td></tr></table></figure><br>假设要删除远程仓库 origin 中的 feature-branch 分支，命令如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin --delete feature-branch<br></code></pre></td></tr></table></figure></p>
<h3 id="标签管理-1"><a href="#标签管理-1" class="headerlink" title="标签管理"></a>标签管理</h3><p>在进行远程标签管理之前，需要先获取远程标签的信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git fetch &lt;remote&gt; --tags<br></code></pre></td></tr></table></figure><br>例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git fetch origin --tags<br></code></pre></td></tr></table></figure></p>
<h4 id="推送标签到远程仓库"><a href="#推送标签到远程仓库" class="headerlink" title="推送标签到远程仓库"></a>推送标签到远程仓库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push &lt;remote&gt; &lt;tag-name&gt;    //推送单个标签<br>git push &lt;remote&gt; --tags        //推送单个标签<br></code></pre></td></tr></table></figure>
<p>例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin v1.0<br>git push origin --tags<br></code></pre></td></tr></table></figure></p>
<h4 id="查看远程标签"><a href="#查看远程标签" class="headerlink" title="查看远程标签"></a>查看远程标签</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git tag<br></code></pre></td></tr></table></figure>
<h4 id="删除远程标签"><a href="#删除远程标签" class="headerlink" title="删除远程标签"></a>删除远程标签</h4><p>先删除本地标签,然后删除远程标签：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push &lt;remote&gt; --delete &lt;tag-name&gt;<br></code></pre></td></tr></table></figure><br>例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin --delete v1.0<br></code></pre></td></tr></table></figure></p>
<h4 id="更新远程标签"><a href="#更新远程标签" class="headerlink" title="更新远程标签"></a>更新远程标签</h4><p>在 Git 中，标签是不可变的。因此，要更新标签，需要先删除旧的标签并重新推送。<br>先删除本地和远程的旧标签。再创建新的标签。最后推送新的标签到远程。</p>
<h4 id="发布-release"><a href="#发布-release" class="headerlink" title="发布(release)"></a>发布(release)</h4><p>创佳完标签以后就可以在github这样的远程仓库发布。直接进入远程仓库的网页，一般在右下角可以根据提示将创建了标签的版本发布。<br><img src="https://raw.githubusercontent.com/fallingnight131/media_resource/blog/image/20250308023027350.png" alt></p>
<h1 id="多人开发事项"><a href="#多人开发事项" class="headerlink" title="多人开发事项"></a>多人开发事项</h1><h2 id="一般团队开发流程"><a href="#一般团队开发流程" class="headerlink" title="一般团队开发流程"></a>一般团队开发流程</h2><p>对于一个多人完成的项目而言，在一个项目建立的时候，技术负责人创建一个github仓库，创建一个main分支,main分支是门面，是后续发布的根本，所以main分支必须是纯净的，因此在main的基础上创建一个dev分支，dev(develop)分支负责开发，后续的改动都在dev分支上面进行。团队的不同人负责不同的事情，比如张三负责增加菜单，王五负责增加背景音乐，那他们就分别在dev的基础上再分别开一个feature/menu和feature/music分支并在这两个分支上面做开发和改动，当开发的差不多了，就将这两个分支合并到dev分支，当开发到了一个阶段(比如实现了基本功能)，就由负责人在dev分支的基础是建立一个release分支，在这个分支上做最后的调试和bug修复，最后当一切都没有问题了，再由负责人将release合并到main分支。这样一来，main分支的代码始终是纯净的，稳定的，也方便了后续的发布和部署。</p>
<h2 id="对项目做贡献"><a href="#对项目做贡献" class="headerlink" title="对项目做贡献"></a>对项目做贡献</h2><p>对于仓库创建者以外的成员(或者想给项目做贡献的人)，需要进入项目的仓库去fork这个仓库。<br>在英文中，”fork” 的字面意思是“叉”或“分叉”。在软件开发中，Fork 代表“分支”或“分流”的含义。它表示在某个项目或代码库的基础上“分出一条支流”，以独立的副本形式进行修改和发展。这个分支副本可以随着开发者的需求进行调整、增强或定制，与原始项目保持一定的独立性。</p>
<h3 id="Fork-仓库"><a href="#Fork-仓库" class="headerlink" title="Fork 仓库"></a>Fork 仓库</h3><p>fork的按钮一般在仓库的右上角<br><img src="https://raw.githubusercontent.com/fallingnight131/media_resource/blog/image/20250308023112295.png" alt><br>在仓库页面右上角找到 “Fork” 按钮，点击后 GitHub 会在你的账户下创建一个该仓库的副本。<br>完成后，页面会跳转到你账户中的新 Fork 仓库，仓库名称会以 &lt;你的用户名&gt;/&lt;仓库名&gt; 的形式显示。</p>
<h3 id="将-Fork-的仓库克隆到本地"><a href="#将-Fork-的仓库克隆到本地" class="headerlink" title="将 Fork 的仓库克隆到本地"></a>将 Fork 的仓库克隆到本地</h3><p>在你自己的 Fork 仓库页面中，克隆这个仓库到你的本地系统(替换 <URL> 为你复制的仓库地址)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> &lt;URL&gt;<br></code></pre></td></tr></table></figure><br>随后进入克隆后的仓库目录。</URL></p>
<h3 id="配置远程仓库"><a href="#配置远程仓库" class="headerlink" title="配置远程仓库"></a>配置远程仓库</h3><p>默认情况下，Git 会将你的 Fork 仓库设为远程仓库（一般称为 origin）。但是，为了便于与原始仓库保持同步，通常会将原始仓库添加为另一个远程仓库，称为 upstream：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote add upstream &lt;original-repository-URL&gt;<br></code></pre></td></tr></table></figure><br>original-repository-URL是原始仓库的UPL</p>
<p>这样你的仓库就会有两个远程：<br>origin：指向你的 Fork 仓库。<br>upstream：指向原始仓库。</p>
<h3 id="从原始仓库同步更新"><a href="#从原始仓库同步更新" class="headerlink" title="从原始仓库同步更新"></a>从原始仓库同步更新</h3><p>为了保持你的 Fork 仓库与原始仓库的最新内容一致，定期同步更新是很重要的：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git fetch upstream<br>git merge upstream/main<br></code></pre></td></tr></table></figure><br>也可以使用 rebase，保持更整洁的提交记录：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git rebase upstream/main<br></code></pre></td></tr></table></figure></p>
<h3 id="在-Fork-仓库中创建新分支并进行修改"><a href="#在-Fork-仓库中创建新分支并进行修改" class="headerlink" title="在 Fork 仓库中创建新分支并进行修改"></a>在 Fork 仓库中创建新分支并进行修改</h3><p>创建并切换到一个新的分支，便于进行修改：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -b &lt;new-branch-name&gt;<br></code></pre></td></tr></table></figure><br>在新分支上进行修改、提交更改：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .<br>git commit -m <span class="hljs-string">&quot;Description of changes&quot;</span><br></code></pre></td></tr></table></figure></p>
<h3 id="推送分支到你的-Fork-仓库"><a href="#推送分支到你的-Fork-仓库" class="headerlink" title="推送分支到你的 Fork 仓库"></a>推送分支到你的 Fork 仓库</h3><p>将你新分支上的更改推送到 GitHub 上的 Fork 仓库：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin &lt;new-branch-name&gt;<br></code></pre></td></tr></table></figure></p>
<h3 id="提交-Pull-Request-PR"><a href="#提交-Pull-Request-PR" class="headerlink" title="提交 Pull Request (PR)"></a>提交 Pull Request (PR)</h3><p>在你的 Fork 仓库页面中，在左上角选择 Pull Request。<br><img src="https://raw.githubusercontent.com/fallingnight131/media_resource/blog/image/20250308023157591.png" alt><br>进入Pull Request以后点击New Pull Request<br><img src="https://raw.githubusercontent.com/fallingnight131/media_resource/blog/image/20250308023253392.png" alt><br>编写 PR 描述，解释你所做的更改，并选择合适的目标分支（通常是 main 或 develop)。<br>提交 PR，等待原始仓库的维护者审核和合并。</p>
<h3 id="同步最新更新"><a href="#同步最新更新" class="headerlink" title="同步最新更新"></a>同步最新更新</h3><p>在原始仓库有新的更新时，可以通过以下命令保持同步：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git fetch upstream<br>git merge upstream/main<br>git push origin main<br></code></pre></td></tr></table></figure></p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>在多人开发中，应当:</p>
<ul>
<li>用git revert 代替git reset</li>
<li>禁止在最近一次创建或合并分支的结点之前使用git reset 或者git rebase</li>
<li>严禁对不止一人交互的仓库使用git push —force</li>
</ul>
<p>上述三条注意事项都是为了避免对提交历史造成关键性影响，对提交历史的更改在多人协作中可能造成拉取和推送的冲突，而且还会影响到其他成员的工作。所以在多人开发中应该尽量通过创建新的提交来代替更改以往的提交。</p><div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2024/11/19/%E7%94%A8Matlab%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E6%B3%95/">← 下一篇 用Matlab实现高斯消元法</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2024/10/22/P1002-%E8%BF%87%E6%B2%B3%E5%8D%92/">P1002-过河卒 上一篇 →</a></div></div></div><div id="comments"><div id="valine"></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="回到顶部" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="文章目录">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="切换主题"></a><a onclick="
        const bgm = document.getElementById('bgm');
        const control = document.getElementById(&quot;bgm-control&quot;);
        if (bgm.paused) {
          bgm.play();
          control.setAttribute(&quot;fill&quot;, &quot;#18d1ff&quot;);
          control.style.transform = &quot;scaleY(1)&quot;;
        } else {
          bgm.pause();
          control.setAttribute(&quot;fill&quot;, &quot;currentColor&quot;);
          control.style.transform = &quot;scaleY(.5)&quot;;
        }
      "><svg id="bgm-control" viewBox="0 0 30 34" fill="currentColor" style="width: auto; height: 80%; transition: transform .3s;"><path d="M25.998 23.422V11.29h3.999v12.132h-3.999zM19.497 6.234h4.001v22.243h-4.001V6.234zM12.998.867h4v32.978h-4V.867zm-6.5 5.367h4.001v22.243H6.498V6.234zm-6.5 5.056h4v12.132h-4V11.29z"></path></svg><audio id="bgm" src="https://raw.githubusercontent.com/fallingnight131/media_resource/blog/audio/lifestream(machine).mp3" loop crossorigin="anonymous"></audio></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="/img/avatar/amiya.jpg" alt="Logo"></a><h1 id="Dr"><a href="/">落夜织寒</a></h1><div id="description"><p>你说这片大地不是无限的，它只是一颗圆球上的一摞泥土; 你说星星和我们脚下的一样，都是天轨上漂行的舟筏......</p></div><div id="social-links"><a class="social" target="_blank" rel="noopener" href="https://github.com/fallingnight131"><i class="fab fa-github" alt="GitHub"></i></a><a class="social" href="mailto:fallingnight131@gmail.com"><i class="fa fa-envelope" alt="E-Mail"></i></a><a class="social" target="_blank" rel="noopener" href="https://space.bilibili.com/436807040"><i class="fab fa-bilibili" alt="BiliBili"></i></a><a class="social" target="_blank" rel="noopener" href="https://www.zhihu.com/people/29-1-50-73"><i class="fab fa-zhihu" alt="Zhihu"></i></a></div></div><div id="aside-block"><div id="toc-div"><h1>目录</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#git%E5%92%8Cgithub%E7%9A%84%E5%85%B3%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="toc-number">1.</span> <span class="toc-text">git和github的关系和区别</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#git"><span class="toc-number">1.1.</span> <span class="toc-text">git</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#github"><span class="toc-number">1.2.</span> <span class="toc-text">github</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#git%E5%91%BD%E4%BB%A4"><span class="toc-number">2.</span> <span class="toc-text">git命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E7%B1%BB%E5%91%BD%E4%BB%A4"><span class="toc-number">2.1.</span> <span class="toc-text">配置类命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E5%85%A8%E5%B1%80%E7%94%A8%E6%88%B7%E5%90%8D"><span class="toc-number">2.1.1.</span> <span class="toc-text">配置全局用户名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E5%85%A8%E5%B1%80%E9%82%AE%E7%AE%B1"><span class="toc-number">2.1.2.</span> <span class="toc-text">配置全局邮箱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E7%9A%84%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8"><span class="toc-number">2.1.3.</span> <span class="toc-text">设置默认的文本编辑器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%91%BD%E4%BB%A4"><span class="toc-number">2.2.</span> <span class="toc-text">本地仓库命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%BB%93%E5%BA%93"><span class="toc-number">2.2.1.</span> <span class="toc-text">创建仓库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%94%B9%E7%BC%93%E5%AD%98"><span class="toc-number">2.2.2.</span> <span class="toc-text">更改缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E7%89%88%E6%9C%AC"><span class="toc-number">2.2.3.</span> <span class="toc-text">提交版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E5%9B%9E%E6%BB%9A"><span class="toc-number">2.2.4.</span> <span class="toc-text">版本回滚</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#git-reset%E5%91%BD%E4%BB%A4"><span class="toc-number">2.2.4.1.</span> <span class="toc-text">git reset命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#git-revert%E5%91%BD%E4%BB%A4"><span class="toc-number">2.2.4.2.</span> <span class="toc-text">git revert命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#git-restore%E5%91%BD%E4%BB%A4"><span class="toc-number">2.2.4.3.</span> <span class="toc-text">git restore命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E7%89%88%E6%9C%AC%E4%BF%A1%E6%81%AF"><span class="toc-number">2.2.5.</span> <span class="toc-text">修改版本信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86"><span class="toc-number">2.2.6.</span> <span class="toc-text">分支管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%88%86%E6%94%AF"><span class="toc-number">2.2.6.1.</span> <span class="toc-text">创建分支</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E6%8D%A2%E5%88%86%E6%94%AF"><span class="toc-number">2.2.6.2.</span> <span class="toc-text">切换分支</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E5%87%BA%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF"><span class="toc-number">2.2.6.3.</span> <span class="toc-text">列出本地分支</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%88%86%E6%94%AF"><span class="toc-number">2.2.6.4.</span> <span class="toc-text">删除分支</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF"><span class="toc-number">2.2.6.5.</span> <span class="toc-text">合并分支</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8merge%E5%90%88%E5%B9%B6"><span class="toc-number">2.2.6.5.1.</span> <span class="toc-text">用merge合并</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8rebase%E5%90%88%E5%B9%B6"><span class="toc-number">2.2.6.5.2.</span> <span class="toc-text">用rebase合并</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E7%AD%BE%E7%AE%A1%E7%90%86"><span class="toc-number">2.2.7.</span> <span class="toc-text">标签管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%A0%87%E7%AD%BE"><span class="toc-number">2.2.7.1.</span> <span class="toc-text">创建标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E5%87%BA%E6%89%80%E6%9C%89%E6%A0%87%E7%AD%BE"><span class="toc-number">2.2.7.2.</span> <span class="toc-text">列出所有标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%A0%87%E7%AD%BE"><span class="toc-number">2.2.7.3.</span> <span class="toc-text">删除标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%A0%87%E7%AD%BE%E8%AF%A6%E6%83%85"><span class="toc-number">2.2.7.4.</span> <span class="toc-text">查看标签详情</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E5%87%BA%E5%88%B0%E6%A0%87%E7%AD%BE%E7%89%88%E6%9C%AC"><span class="toc-number">2.2.7.5.</span> <span class="toc-text">检出到标签版本</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%91%BD%E4%BB%A4"><span class="toc-number">2.3.</span> <span class="toc-text">远程仓库命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93"><span class="toc-number">2.3.1.</span> <span class="toc-text">增加远程仓库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%BB%BA%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF"><span class="toc-number">2.3.2.</span> <span class="toc-text">新建远程分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E6%8D%A2%E4%B8%8A%E6%B8%B8%E5%88%86%E6%94%AF"><span class="toc-number">2.3.3.</span> <span class="toc-text">切换上游分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%89%E5%8F%96%E4%B8%8E%E6%8E%A8%E9%80%81"><span class="toc-number">2.3.4.</span> <span class="toc-text">拉取与推送</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%89%E5%8F%96%E8%BF%9C%E7%A8%8B%E6%9B%B4%E6%96%B0"><span class="toc-number">2.3.4.1.</span> <span class="toc-text">拉取远程更新</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A8%E9%80%81%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93"><span class="toc-number">2.3.4.2.</span> <span class="toc-text">推送到远程仓库</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%88%86%E6%94%AF-1"><span class="toc-number">2.3.5.</span> <span class="toc-text">删除分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E7%AD%BE%E7%AE%A1%E7%90%86-1"><span class="toc-number">2.3.6.</span> <span class="toc-text">标签管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A8%E9%80%81%E6%A0%87%E7%AD%BE%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93"><span class="toc-number">2.3.6.1.</span> <span class="toc-text">推送标签到远程仓库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E8%BF%9C%E7%A8%8B%E6%A0%87%E7%AD%BE"><span class="toc-number">2.3.6.2.</span> <span class="toc-text">查看远程标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%BF%9C%E7%A8%8B%E6%A0%87%E7%AD%BE"><span class="toc-number">2.3.6.3.</span> <span class="toc-text">删除远程标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E8%BF%9C%E7%A8%8B%E6%A0%87%E7%AD%BE"><span class="toc-number">2.3.6.4.</span> <span class="toc-text">更新远程标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E5%B8%83-release"><span class="toc-number">2.3.6.5.</span> <span class="toc-text">发布(release)</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E4%BA%BA%E5%BC%80%E5%8F%91%E4%BA%8B%E9%A1%B9"><span class="toc-number">3.</span> <span class="toc-text">多人开发事项</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E5%9B%A2%E9%98%9F%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B"><span class="toc-number">3.1.</span> <span class="toc-text">一般团队开发流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E9%A1%B9%E7%9B%AE%E5%81%9A%E8%B4%A1%E7%8C%AE"><span class="toc-number">3.2.</span> <span class="toc-text">对项目做贡献</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Fork-%E4%BB%93%E5%BA%93"><span class="toc-number">3.2.1.</span> <span class="toc-text">Fork 仓库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86-Fork-%E7%9A%84%E4%BB%93%E5%BA%93%E5%85%8B%E9%9A%86%E5%88%B0%E6%9C%AC%E5%9C%B0"><span class="toc-number">3.2.2.</span> <span class="toc-text">将 Fork 的仓库克隆到本地</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93"><span class="toc-number">3.2.3.</span> <span class="toc-text">配置远程仓库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%8E%9F%E5%A7%8B%E4%BB%93%E5%BA%93%E5%90%8C%E6%AD%A5%E6%9B%B4%E6%96%B0"><span class="toc-number">3.2.4.</span> <span class="toc-text">从原始仓库同步更新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8-Fork-%E4%BB%93%E5%BA%93%E4%B8%AD%E5%88%9B%E5%BB%BA%E6%96%B0%E5%88%86%E6%94%AF%E5%B9%B6%E8%BF%9B%E8%A1%8C%E4%BF%AE%E6%94%B9"><span class="toc-number">3.2.5.</span> <span class="toc-text">在 Fork 仓库中创建新分支并进行修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A8%E9%80%81%E5%88%86%E6%94%AF%E5%88%B0%E4%BD%A0%E7%9A%84-Fork-%E4%BB%93%E5%BA%93"><span class="toc-number">3.2.6.</span> <span class="toc-text">推送分支到你的 Fork 仓库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4-Pull-Request-PR"><span class="toc-number">3.2.7.</span> <span class="toc-text">提交 Pull Request (PR)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%9C%80%E6%96%B0%E6%9B%B4%E6%96%B0"><span class="toc-number">3.2.8.</span> <span class="toc-text">同步最新更新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">3.2.9.</span> <span class="toc-text">注意事项</span></a></li></ol></li></ol></li></ol></div></div><footer><nobr><span class="icp-title">ICP</span><a class="icp-content" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">暂由github pages托管</a></nobr><br><nobr><span class="icp-title">copyright</span><a class="icp-content" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0</a></nobr><br><nobr>构建自 <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> 使用主题 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> 主题作者 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas></body></html>