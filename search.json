[{"title":"Hello World(第一次使用hexo框架搭博客的过程)","url":"/2024/10/06/hello-world/","content":"怎么有人在博客写怎么搭博客\n第一次写博客，就简述一下我用hexo搭建博客的过程吧。\n要安装的环境gitGit 是一个开源的分布式版本控制系统，git自带的git bash可以让你在如windows这样的操作系统上也能执行Linux的命令。这在后续安装hexo时执行安装命令，以及部署hexo到github上时，会发挥其作用。git的下载网站如下：https://git-scm.com/下载完毕以后，记得打开 Path 变量，添加本地环境安装目录（确保文件位置到达 cmd ）。\n\n安装以后，就可以右键菜单中找到并使用git bash了\n\nnode.js运行 Hexo 需要 JavaScript 环境, Hexo 的命令行工具（如 hexo init、hexo generate、hexo deploy 等）都是 JavaScript 脚本，它们依赖于 node.js 来运行。因此，安装 Node.js 是为了提供执行 Hexo 的环境。node.js下载网站如下：https://nodejs.org/en/按照提示，d盘随便开个地方下载就行。记得直接下载那个LTS版本。\nhexonpm install -g hexo-cli\n直接在任意地方打开git bash输入上述指令就行，hexo会被安装到你的 npm 全局目录，它的执行文件会被加入到环境变量path中，之后你就可以在任意终端中执行hexo命令。\n在本地搭建博客初始化hexo init blog\n在磁盘中找一个好位置（通常就是你平时新建项目的地方）通过上述命令初始化 Hexo 项目（当然，上述命令中的blog也可以改成其他名字）之后你就得到了一个叫blog（或者其他名字）的项目文件夹，初始化的工作就完成了。\n\n生成随后用一个你平时常用的集成开发环境（推荐vscode、WebStorm）打开之前得到的项目文件夹（blog）。在blog这一级文件夹中使用命令：hexo g该指令的作用是在Hexo站点根目录下自动生成静态文件，这些文件通常被保存在一个名为“public”的文件夹中。（通常是html文件）如果命令执行失败了，可以试试执行：npm install再重新执行之前的指令。\n启动本地服务器生成完毕以后，就可以在本地浏览先前生成的网页了。通过执行hexo s在终端获得一个网站\n\n打开网站就进入了通过hexo生成的初始博客界面\n\n主题刚刚生成的博客界面较为简陋，可以通过替换主题令其符合我们喜欢风格主题可以在官网提供的主题栏下载：https://hexo.io/themes/点开想要下载的主题后一般会进入相应的github仓库，随后跟着相应的readme文件教程配置就行。\n部署只能在本地运行就意味着别人看不到，这与我们的期望相悖了，想要让博客可以在网上被别人查看，我们可以将其部署在github page上，再关联一个域名。\n新建仓库先在github新建一个仓库，一定要注意的是，仓库名要设置为username.github.io ,其中username就是你github的账户名，不这么取名就部署不了。\n配置_config.yml文件在blog目录下找到_config.yml文件，在文件的末尾加上如下代码：deploy:  type: git  repository: https://github.com/username/username.github.io.git  branch: main其中，username替换成你github的账户名（repository就是那个仓库的网址）\n执行部署命令在终端输入：hexo deploy之后完成部署\n查看博客在浏览器的网址栏输入username.github.io,也就是之前的仓库名，就能进入你博客的首页了。\n关联域名虽然通过username.github.io就可以查看自己的博客，但是在平时的生活经验中，网址的后缀一般都是.com、.cn这种，.github.io这种结尾在其他人看来会十分突兀，我们当然希望别人可通过.com、.cn这种符合生活经验的网址来查看我们的博客。要实现这点，我们可以关联一个域名到原本的github page上面，这样我们通过原本username.github.io这样的网址和新的网址就都可以访问博客了。\n获取域名国内我们可以在阿里云、腾讯云这样的网站购买域名，像.com这样的域名会贵一些，.cn、.top之类的价格就民亲多了。价格还会和域名的名字有关，名字是要你自己取的，可以在官方平台查询你取的域名在不同后缀的价格。阿里云官网查询的网址如下：&lt;阿里云域名查询&gt;进去直接在搜索框输入你取的域名就行，如果你取了类似aaa这样的域名的话，你可能会看见打底几万的天价，所以取名的时候尽量避免这种特殊的名字，如果你取的名字实在太贵可以在后面加几个数字试试。正常情况下你会看见如下的价位：\n\n追求性价比的话选个top的后缀也不错，当然，如果你要选com和cn也完全没问题,就是可能贵点。直接点注册就行，第一次注册域名会要求你实名认证，照着提示认证就行（不然后面解析和续费啥的都会受影响）。注册完域名以后，我们就有了一个可以关联到之前github page的新网址。\n解析域名在阿里云首页点击右上角控制台，进入控制台后点击左上角菜单点击域名\n\n点击左边域名列表，就能查看到之前注册的域名了，在操作一栏选择解析，再点击添加记录，之后按照如下填法添加两条记录：\n\n\n其中记录值那里就填你先前在github page浏览博客时用的网址(不用带http)\ngithub page配置之后进入原先的代码仓库，点击setting，然后点击左侧菜单的page选项\n\n进入之后，找到Custom domain\n\n在其中填入你之前注册的新域名，一开始可能会失败，失败了就等待一会再试试成功了以后，新域名就可以访问你的博客了，而且原先.github.io的域名也可以访问，也就是说现在，你有两个网址可以打开你的博客。\n注意配置好github page之后在你的github仓库里面会生成一个名叫CNAME的文件，记得把这个文件拷贝到本地，不然在后续更新博客的时候会把仓库里面的CNAME文件抹去，CNAME文件没了就只能重新进行github page配置了，否则用新域名就无法访问博客了。\n更新博客上传更新的内容在修改了博客的内容之后，想要更新之前上传在github的博客内容，在终端输入hexo deploy -g就能将更新的内容上传了。\n修改文章内容在blog/source/_posts目录下，你会发现.md文件，这种文件支持markdown语法，通过修改这些文件的内容就可以实现对文章内容的修改。\n增加新的页面在终端中执行hexo new page &#x27;pagename&#x27;可以新建一个页面，这个页面会以文件夹的形式生成在blog/source下，其中pagename可以替换成其他名字，在网页中，新的页面和Home以及Achieve同级\n增加新的文章在终端中执行hexo new &quot;postname&quot;可以新建一个文章，这个文章生成在blog/source/_posts下，其中postname可以替换成其他名字，生成的文件是.md文件，可以通过markdown语法编写。\n到这里，基础的hexo使用方法就这样了，想要有更加炫酷的界面，可以参考主题和插件。其他的实在暂时想不到了，想到了再加，开摆！\n","categories":["心得分享"],"tags":["hexo"]},{"title":"Git和Github基本用法","url":"/2024/10/26/Git%E5%92%8CGithub%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/","content":"《基本用法》\ngit和github的关系和区别git说到git，很多初学者的第一印象是github，好像git的用处就是从github仓库clone项目，或者也可以把自己的项目上传到github，但是为什么要上传，也不是很清楚。\n其实，git作为一个分布式版本控制系统，是一个命令行工具，它最根本的功能是用于在本地管理和跟踪文件的更改历史，或者用更好理解的说法，git的基础功能是“存档”。\n在打游戏的时候，你会时不时存个档，这样干了什么傻事以后还可以回档，比如你不小心销毁了一件很重要的装备以后，你可以通过回档撤销你干的傻事。同时，有些游戏还支持备份存档，也就是说你可以在这个存档的基础上，复制一个平行的存档，新存档生成的时候和原来的存档游戏进度相同，但是当新存档生成以后，就和原来的存档互不影响了，你可以在备份的存档里面干各种原来不敢在主存档干的事，就算把装备都融了，屋子都炸了也不用在意。有些游戏还支持存档互通，你在备份存档里面打败了新的boss，有了更好的装备，还可以送回主存档，加快主存档的进度。这样一来，坏事影响不了主存档，好事却可以。而存档文件通常不大，100多个G的游戏玩了几个月的存档文件可能还不到100M。有了存档的机制，你玩游戏的时候会更加放松工具自在。\ngit差不多就是这么一个玩意，git的本地仓库干的就是存档的活。有时候你会担心把原本良好的代码改坏而蹑手蹑脚，亦或者你有时突然感觉之前的代码更好。如果你每次改代码前都留一个备份，那你的文件夹会看起来很乱，而且每留一版备份，就会多一用倍的存储空间，十分不方便。而git所包含的版本控制功能就很好的解决解决了这个问题。git commit对应了游戏中的手动存档;git reset、git revert、git restore等命令对应了游戏中的回档;git branch对应了游戏中备份了一个平行存档;git checkout对应了切换存档;git merge对应了将其他备份存档的装备送到主存档。。。。。。有了这个类别，git的意义也就很好理解了。\ngithubgit并不依赖github，git甚至不联网都能用，git是单人开发的时候也可以使用的工具，便于存档回档而存在。而github却依赖git，github是一个代码托管平台，它利用git来进行版本控制，允许你将本地的git仓库推送到远程，并与他人共享代码。除了github以外，国内还有类似gitee这样功能相似的平台，它们的基本功能是相似的。\n除去让别人看得到自己的代码(开源)以外，github最核心的功能便是多人开发。对于一个多人完成的项目而言，每个成员闭门造车肯定会效率低下。github提供了一个多人协作的良好平台。在一个项目建立的时候，技术负责人创建一个github仓库，创建一个main分支,main分支是门面，是后续发布的根本，所以main分支必须是纯净的，所以在main的基础上创建一个dev分支，dev(develop)分支负责开发，后续的改动都在dev分支上面进行。团队的不同人负责不同的事情，比如张三负责增加菜单，王五负责增加背景音乐，那他们就分别在dev的基础上再分别开一个feature/menu和feature/music分支并在这两个分支上面做开发和改动，当开发的差不多了，就将这两个分支合并到dev分支，当开发到了一个阶段(比如实现了基本功能)，就由负责人在dev分支的基础是建立一个release分支，在这个分支上做最后的调试和bug修复，最后当一切都没有问题了，再由负责人将release合并到main分支。这样一来，main分支的代码始终是纯净的，稳定的，也方便了后续的发布和部署。\ngit命令配置类命令配置全局用户名git config --global user.name &quot;Your Name&quot;\n配置全局邮箱git config --global user.email &quot;you@example.com&quot;\n配置全局用户名和邮箱有助于多人开发时让别人知道相关提交源自于谁\n设置默认的文本编辑器git config --global core.editor &quot;code --wait&quot;   //vscodegit config --global core.editor &quot;vim&quot;           //vimgit config --global core.editor &quot;subl -n -w&quot;    //sublime textgit config --global core.editor &quot;atom --wait&quot;   //atomgit config --global core.editor &quot;clion --wait&quot;  //cliongit config --global core.editor &quot;charm -w&quot;      //pycharm\n在进行commit操作以后，如果没有增加提交描述，git会强制打开一个默认文本编辑器让你编辑提交描述(一般默认是vim)，对于不熟悉vim的人而言，这会十分麻烦，设置一个趁手的默认文本编辑器会让编辑过程方便一些。\n本地仓库命令创建仓库在项目文件夹根目录输入git init初始化仓库以后，在根目录会出现一个名为.git的隐藏文件夹(要在文件资源管理器-&gt;查看-&gt;显示中勾选隐藏的项目才能看到)，就是由这个文件夹记录git仓库的各种信息和各种分支、提交。删掉这个文件夹，也就删掉了本地仓库，这时就又要通过git init重新创建本地仓库了。\n更改缓存git add &lt;file&gt;              //将单个文件添加到暂存区。git add .                   //添加当前目录下的所有文件到暂存区。git reset &lt;file&gt;            //清理特定文件的缓存git reset                   //清理所有暂存的更改git restore --staged &lt;file&gt; //效果和git reset &lt;file&gt;类似git restore --staged .      //效果和git reset 类似git reset --hard            //清除未提交的所有更改（包括暂存区和工作区）git rm --cached &lt;file&gt;      //删除暂存区中特定文件的缓存，并且让Git停止追踪它git rm -r --cached .        //删除暂存区中所有文件的缓存，并且让Git停止追踪它们\n在提交版本(存档)前需要提交的内容放入缓存，为后续提交指定范围。如果要查看缓存的状态，我们可以使用git status来查看哪些文件被缓存，哪些被追踪的文件没有被缓存如果不出意外，你会觉得一个一个添加缓存很慢，我们当然希望能用一个命令就把该缓存的全都缓存、该删除缓存的全都删除了。但是直接用git add .又不合理，因为比如.venv(虚拟环境)、build这样的文件是不应该被git追踪并缓存的。因为这些文件很大、而且他们的变化是编译或者安装库的结果，不是我们应该关系的，也不是应该由我们手动更改的。我们需要一种方法，将这些文件排除在版本控制之外。git提供了一种方法将文件或者文件夹排除在版本控制之外————.gitignore首先，在要排除的文件或者文件夹所在的那一级目录新建一个文件，取名为.gitignore 。注意前面的点不要漏掉。随后，将要排除的文件夹或者文件的名字填入其中，一行一个，再保存一下，这些被填入其中的文件和文件夹就被排除在版本控制之外了。有些时候.gitignore可能不生效，可以试试删了重建.gitignore ，在输入以下命令让Git停止追踪要忽略的内容git rm -r --cached .git add .当确定.gitignore生效以后，此后每次提交前更改缓存就只要执行git add .就行了。\n提交版本提交版本相对应给游戏存档，是git最核心的功能，版本提交命令如下：git commit                      //不带提交描述git commit -m &quot;commit message&quot;  //带提交描述对应git，每次commit都是必须携带提交描述的，而且不能用空字符串代替，对于第一种命令，git会打开默认文本编辑器让你编辑提交信息，不会用vim记得按照本文前面的内容修改默认文本编辑器。\n在第一行的空白处填上提交描述，保存以后关闭文本编辑器，提交就完成了。\n对于第二种命令，直接将描述写在引号里面就行，不需要再去编辑文本编辑器。\n如果需要查看之前提交过的版本，可以通过以下命令查看提交日志git log             //打印日志完整信息git log --oneline   //打印日志简略信息，每次提交占一行\n如果想要回到之前某一次提交之后，查看那次提交的工作区状态，可以通过命令git checkout &lt;commit-hash&gt;回到那次提交后的状态。\n是那次的哈希值，git会为每次提交生成独一无二的哈希值，哈希值可以通过查看提交日志知晓。这个命令可以改变HEAD指针，但是这种状态类似只读状态，你在工作区做的任何更改都不会被保留。查看完以后，可以通过git checkout -返回最后一次提交的状态\n版本回滚版本回滚相对应游戏里的回档，可以通过以下几种命令进行版本回滚。\ngit reset命令git reset --soft &lt;commit-hash&gt;       //仅重置 HEAD，不影响暂存区和工作区git reset --mixed &lt;commit-hash&gt;      //重置 HEAD 和暂存区，保留工作区更改（默认）git reset --hard &lt;commit-hash&gt;       //重置 HEAD、暂存区和工作区，彻底清除后续所有更改\n使用soft后缀的话，只会将那次提交之后的所有提交去除，但是工作区和缓存区都不会改变，如果你觉得某次提交之后的所有提交都没有什么实际意义，你希望自己的提交历史看起来清爽一点，但又感觉现在的工作区还不错，不想改动工作区，那不妨试试这个命令。mixed后缀是git reset的默认方法，也就是如果你不加—后缀，就会默认带了—mixed，和soft的区别是，mixed还重置了缓存区，便于你进行手动恢复文件之类的操作(虽然并不是很好用)如果希望完全回档，推荐使用hard后缀，hard后缀可以完全重置到那次提交以后的HEAD、暂存区和工作区，是最符合“回档”期望的命令，如果觉得某次提交之后的代码越写越屎，可以直接用这个命令穿越回过去(bushi)直接撤回最近一次提交可以用git reset --hard HEAD~1同理，如果你希望撤回最近n次提交，可以使用git reset --hard HEAD~n如果想直接回到最近一次提交，清除未提交的所有更改（包括暂存区和工作区），可以使用git reset --hard\ngit revert命令git reset简单粗暴，但也有其弊端，git reset会完全丢弃回滚的那次提交以后的所有提交，也就是说你回档以后又后悔了，那你就没的后悔了。而且在多人开发中，reset如果回滚到了某次合并分支的结点之前，也会因为两边历史不同而造成冲突，所以在多人开发中，reset只能回退到最近一次合并或创建分支的结点之后，有一定局限。如果要符合多人开发规范，需要使用git revert命令git revert &lt;commit-hash&gt;     //撤销某次提交git revert HEAD              //撤销最新的提交git revert HEAD~3..HEAD      //撤销前3次提交，但是分三次提交git revert -n HEAD~3..HEAD   //撤销前3次提交，但是一次性提交注意，-n是代表不提交模式，三次撤销完了也不会提交，需要git commit -m &quot;Reverted last 3 commits&quot;手动提交能撤销前三次，说明也能撤销前n次，把3改成其他数字就行。和reset不一样，reset是撤销到某次提交之后，而revert则是撤销某次提交，没有之后。记得不要撤销过头。git revert不会移除任何提交信息，而是在当前分支上创建一个新的提交，这个提交的内容会“反向应用”指定的更改，也就是说，使用git revert以后，提交历史反而会变多。git revert和git reset相比不会在多人开发中产生因为历史不同而生的冲突和错误。git revert可以撤销中间几次的提交，比如git revert -n HEAD~7..HEAD~4是撤销倒数第5次和倒数第6次提交。记得，git revert -n HEAD~x..HEAD~y撤销的是倒数第y+1到倒数第x-1次提交，不是倒数y到x次提交！很反常识对吗，反正找个理由说服自己就行。。。。。。在git revert的时候，特别是撤销中间几次提交的时候，很容易发送冲突，这时候git会打开默认文本编辑器让你解决冲突，按照预期取舍就行，实在不知道怎么搞就点击接受组合。在git revert的过程中，当你处于一个操作中，你可以通过下述命令选择继续、放弃或退出该操作。git revert --continue   //如果你已经解决了冲突或完成了必要的更改，可以继续 revert 操作git revert --abort      //放弃当前的 revert 操作，并将仓库恢复到 revert 操作开始之前的状态。git revert --quit       //退出当前的 revert 操作，但保留已经应用的更改。\ngit restore命令如果你觉得git revert命令太复杂了，到是还有一种更加简单，而且还不破坏提交历史的方法git restore --source=&lt;commit-hash&gt; --staged --worktree .git commit -m &quot;将版本回滚到&lt;commit-hash&gt;状态&quot;这个命令并不会影响提交历史，而是从指定的提交中恢复文件到当前工作目录和暂存区，这意味着当前工作目录中的文件将被替换为指定提交中的版本。这时候再手动commit一下，就可以将那个版本的工作区作为一个新的提交。这样一来，也可以等效达成”回档”的目的，而且因为是在原基础上新建提交，所以并不会破坏之前的提交。不过相比于git revert，git restore命令的跨度太大了，因为是恢复工作区和缓存，而不是回滚，虽然这种方法在多人开发中不会造成冲突，但其规范性还是不如git revert。\n修改版本信息有时你可能觉得之前某次提交不好，但是又不希望弄没之后的提交，这时候你可能需要通过rebase来修改个别提交首先启动启动交互式 rebasegit rebase -i HEAD~4-i 用于启用交互模式，使用命令以后，git会打开默认文本编辑器进行交互编辑中间那个是每次提交的哈希值，右边那个是每次提交的描述(我偷懒随便写的)HEAD后面填了4，所以显示了最近4次提交，用更大的数字可以查看到跟之前的提交之后我们要根据需求更改pick为其他命令常用命令pick：保留该提交。相当于“选择”该提交并按原样应用到新的历史记录中。\nedit：标记该提交需要修改，Git 会在这个提交暂停，允许你进行修改、补充内容或更改提交信息。修改完成后继续 rebase。\nsquash（简写：s）：将当前提交与前一个提交合并，并且会合并两者的提交信息。适用于整理多个小的提交，将它们合并成一个较大的提交。\nfixup（简写：f）：类似于 squash，将当前提交与前一个提交合并，但不会保留当前提交的信息。这在仅想保留前一个提交信息的情况下非常有用。\nreword：保留该提交，但允许修改其提交信息。\ndrop：删除该提交，从历史记录中移除它。\n值得注意的是，reword只能修改提交描述，edit还可以修改那次提交的操作信息，比如你可以在文件里面加点什么删点什么，不过不出意外会出点冲突，这样就又要解决冲突了。比如我们想修改4444那次提交，我们把4444那次提交前面的pick改成edit之后我们保存并关闭编辑文件，就临时进入了那次提交的编辑状态(最近的不再是ddd，而是4444)随后我们修改完相应的文件，用git add .添加缓存，解决完冲突再用命令git rebase --continue进入文本编辑器编辑提交信息，再保存关闭文本编辑器，修改就完成了。最近的一次提交也变回了ddd，而4444那次提交中则增加了你新编辑的那些操作。\n和revert一样，rebase也不止有continue后缀在revert过程中解决了冲突或其他更改，可以用相同命令选择继续、放弃或退出该操作git rebase --continue   //如果你已经解决了冲突或完成了必要的更改，可以继续 rebase 操作git rebase --abort      //放弃当前的 rebase 操作，并将仓库恢复到 rebase 操作开始之前的状态。git rebase --quit       //退出当前的 rebase 操作，但保留已经应用的更改。\n分支管理分支相当于游戏里的备份存档，在git中同样有着十分重要的功能。\n创建分支使用命令git branch &lt;branch_name&gt;你在哪个分支上创建分支，就是在哪个分支的基础上创建分支。。。。。。额，这可能不像是人话。或者说，比如你在main这个分支上输入了git branch dev的命令，那就是在main这个分支的基础上，分出了dev这个分支，dev将会继承main的所有文件信息和提交历史，同时后续对两者编辑又互不影响。\n切换分支使用命令git checkout &lt;branch_name&gt;可以切换到指定分支。切换到不同分支以后，工作区和提交历史都会变成相应分支的状态。\n对应创建分支，如果希望快一点，直接创建并切换到新分支，也可以用git checkout -b &lt;branch_name&gt;直接一步到位。\n列出本地分支使用命令git branch可以列出本地分支的信息。比如：说明本地仓库有两个分支，分别是main和dev，其中main前面有星号意味着目前切换到的分支是main。\n删除分支使用命令git branch -d &lt;branch_name&gt;可以删除本地分支\n合并分支当开发到一点程度的时候，要将分支的内容合并到主干上，有两种方法可以合并分支\n用merge合并一般情况下大多采用merge合并git merge &lt;branch_name&gt;比如要将dev合并到main，那就先切换到main分支，再执行git merge dev这样一来，dev就被合并到了main上但经过这样的合并，main的提交历史就不一定是直线的了。比如我们在dev分支创建以后，先在dev上进行了三次提交，后来又在main上进行了一次提交，那通过merge合并以后，提交历史会变成这样：如果你有某种洁癖，不能忍受非直线的历史，可以尝试后面的方法。\n用rebase合并rebase不仅可以修改提交信息，还可以用来合并分支。在和上面相同的情况下，通过git rebase dev命令达到的效果是这样的：合并以后的提交历史依旧是直线，这样看起来更加干净，当然，如果用git merge也是完全没有问题的。\n标签管理当开发到了一个具有里程意义的时候，需要发布版本，发布前需要增加标签，为发布做准备。\n创建标签git tag -a tag_name commit_hash -m &quot;Tag message&quot;\n-a 指定标签为附注标签。-m 允许添加一个标签说明信息 “Release version 1.0”。commit_hash是标签对应提交版本的哈希值例如：git tag -a v1.0 9fceb02 -m &quot;Release version 1.0&quot;9fceb02也可以换成完整的哈希值\n列出所有标签git tag\n删除标签git tag -d tag_name\n查看标签详情git show tag_name\n检出到标签版本git checkout tag_name\n可以通过git checkout -返回原来的分支。\n远程仓库命令增加远程仓库增加远程仓库可以通过命令git remote add &lt;remote&gt; &lt;remote-URL&gt;实现。远程仓库的名称是由自己来取，不一定和github仓库那边一样，远程仓库URL要在github仓库那里获取，就是git clone后面常跟的那串URL。例如可以添加一个名字取为origin的远程仓库git remote add upstream https://github.com/another/repo.git远程仓库不一定只能添加一个，一个本地仓库可以添加很多个远程仓库(虽然没有必要)，可以通过切换上游分支来便于拉取和推送。可以通过git remote -v查看本地仓库添加了多少远程仓库。\n新建远程分支先在本地创建一个新分支，再切换到这个分支上(如果已经有分支了也可以不用创建，可以直接切换)git checkout -b &lt;local-branch&gt;再将本地新分支推送到远程git push -u &lt;remote&gt; &lt;remote-branch&gt;这样远程就多了一个分支，分支名和设置的一样。例如：git checkout -b feature-branchgit push -u origin feature-branch这里的 -u 会将本地分支与远程分支设置为追踪关系，即将远程分支设置为本地分支的上游，以便将来可以直接使用 git pull 和 git push 来同步。\n切换上游分支git branch --set-upstream-to &lt;remote&gt;/&lt;remote-branch&gt; &lt;local-branch&gt;\n假设你想将本地的 feature 分支设置为跟踪远程的 origin/feature 分支，可以执行以下命令：git branch --set-upstream-to origin/feature feature当然，也可以先切换至feature分支，在执行：git branch -u origin/feature设置了上游分支以后,之后拉取和推送会简化许多。可以通过git branch -vv查看每个本地分支对应的上游如果你不清楚远程仓库有哪些分支，可以通过git fetchgit branch -r查看远程仓库所有分支。其中git fetch是获取远程仓库的所有信息(但是不改变工作区和缓存)如果不想要上游分支了，可以先切换到你想取消上游设置的分支，再通过：git branch --unset-upstream取消上游追踪。\n拉取与推送拉取远程更新git pull &lt;remote&gt; &lt;remote-branch&gt;\n例如从 origin 仓库的 main 分支拉取最新的提交到本地的 main 分支：先切换到main分支。再执行git pull origin main命令。git pull可以看作git fetch + git merge 两个命令的结合也就是说，上述命令可以等效成git fetch &lt;remote&gt; &lt;remote-branch&gt;git merge &lt;remote&gt; &lt;remote-branch&gt;或者git fetch  &lt;remote&gt; &lt;remote-branch&gt;git rebase &lt;remote&gt; &lt;remote-branch&gt;注意，多人协作时应当尽力避免rebase！如果某个本地分支设置了上游分支，在这个本地分支上可以直接执行：git pullgit 会默认从上游分支拉取最新信息。\n推送到远程仓库在push之前，最好先更新本地分支，避免与远程分支之间有冲突。所以先执行：git fetch &lt;remote&gt; &lt;remote-branch&gt;再执行push操作：git push &lt;remote&gt; &lt;remote-branch&gt;例如将本地 main 分支的提交推送到 origin 仓库的 main 分支:先切换到main分支。再执行git fetch origin maingit push origin main命令。如果某个本地分支设置了上游分支，在这个本地分支上可以直接执行：git fetchgit pushgit 会默认向上游分支推送最新信息。如果有很多远程仓库，可以通过git fetch --prune获取所有远程更新并清理无用的远程跟踪分支如果你因为reset或者rebase导致提交历史发生了变化，和远程仓库的历史对不上，那么推送大概率会因为冲突而失败，这时需要一种更强硬的推送命令；git fetchgit push --force &lt;remote&gt; &lt;branch&gt;强制推送会覆盖远程仓库中的分支内容，以匹配本地分支的状态，从而推送成功。但切记，在多人开发中应当极力避免这个命令出现，这会给其他成员造成极大麻烦！\n \n删除分支当一个分支完成了它的使命以后，通常要在本地和远程将这个分支删去。怎么在本地删除分支在前文写了，在远程仓库删除分支需要执行：git push &lt;remote&gt; --delete &lt;remote-branch&gt;假设要删除远程仓库 origin 中的 feature-branch 分支，命令如下：git push origin --delete feature-branch\n标签管理在进行远程标签管理之前，需要先获取远程标签的信息：git fetch &lt;remote&gt; --tags例如：git fetch origin --tags\n推送标签到远程仓库git push &lt;remote&gt; &lt;tag-name&gt;    //推送单个标签git push &lt;remote&gt; --tags        //推送单个标签\n例如：git push origin v1.0git push origin --tags\n查看远程标签git tag\n删除远程标签先删除本地标签,然后删除远程标签：git push &lt;remote&gt; --delete &lt;tag-name&gt;例如：git push origin --delete v1.0\n更新远程标签在 Git 中，标签是不可变的。因此，要更新标签，需要先删除旧的标签并重新推送。先删除本地和远程的旧标签。再创建新的标签。最后推送新的标签到远程。\n发布(release)创佳完标签以后就可以在github这样的远程仓库发布。直接进入远程仓库的网页，一般在右下角可以根据提示将创建了标签的版本发布。\n多人开发事项一般团队开发流程对于一个多人完成的项目而言，在一个项目建立的时候，技术负责人创建一个github仓库，创建一个main分支,main分支是门面，是后续发布的根本，所以main分支必须是纯净的，因此在main的基础上创建一个dev分支，dev(develop)分支负责开发，后续的改动都在dev分支上面进行。团队的不同人负责不同的事情，比如张三负责增加菜单，王五负责增加背景音乐，那他们就分别在dev的基础上再分别开一个feature/menu和feature/music分支并在这两个分支上面做开发和改动，当开发的差不多了，就将这两个分支合并到dev分支，当开发到了一个阶段(比如实现了基本功能)，就由负责人在dev分支的基础是建立一个release分支，在这个分支上做最后的调试和bug修复，最后当一切都没有问题了，再由负责人将release合并到main分支。这样一来，main分支的代码始终是纯净的，稳定的，也方便了后续的发布和部署。\n对项目做贡献对于仓库创建者以外的成员(或者想给项目做贡献的人)，需要进入项目的仓库去fork这个仓库。在英文中，”fork” 的字面意思是“叉”或“分叉”。在软件开发中，Fork 代表“分支”或“分流”的含义。它表示在某个项目或代码库的基础上“分出一条支流”，以独立的副本形式进行修改和发展。这个分支副本可以随着开发者的需求进行调整、增强或定制，与原始项目保持一定的独立性。\nFork 仓库fork的按钮一般在仓库的右上角在仓库页面右上角找到 “Fork” 按钮，点击后 GitHub 会在你的账户下创建一个该仓库的副本。完成后，页面会跳转到你账户中的新 Fork 仓库，仓库名称会以 &lt;你的用户名&gt;/&lt;仓库名&gt; 的形式显示。\n将 Fork 的仓库克隆到本地在你自己的 Fork 仓库页面中，克隆这个仓库到你的本地系统(替换  为你复制的仓库地址)git clone &lt;URL&gt;随后进入克隆后的仓库目录。\n配置远程仓库默认情况下，Git 会将你的 Fork 仓库设为远程仓库（一般称为 origin）。但是，为了便于与原始仓库保持同步，通常会将原始仓库添加为另一个远程仓库，称为 upstream：git remote add upstream &lt;original-repository-URL&gt;original-repository-URL是原始仓库的UPL\n这样你的仓库就会有两个远程：origin：指向你的 Fork 仓库。upstream：指向原始仓库。\n从原始仓库同步更新为了保持你的 Fork 仓库与原始仓库的最新内容一致，定期同步更新是很重要的：git fetch upstreamgit merge upstream/main也可以使用 rebase，保持更整洁的提交记录：git rebase upstream/main\n在 Fork 仓库中创建新分支并进行修改创建并切换到一个新的分支，便于进行修改：git checkout -b &lt;new-branch-name&gt;在新分支上进行修改、提交更改：git add .git commit -m &quot;Description of changes&quot;\n推送分支到你的 Fork 仓库将你新分支上的更改推送到 GitHub 上的 Fork 仓库：git push origin &lt;new-branch-name&gt;\n提交 Pull Request (PR)在你的 Fork 仓库页面中，在左上角选择 Pull Request。进入Pull Request以后点击New Pull Request编写 PR 描述，解释你所做的更改，并选择合适的目标分支（通常是 main 或 develop)。提交 PR，等待原始仓库的维护者审核和合并。\n同步最新更新在原始仓库有新的更新时，可以通过以下命令保持同步：git fetch upstreamgit merge upstream/maingit push origin main\n注意事项在多人开发中，应当:\n\n用git revert 代替git reset\n禁止在最近一次创建或合并分支的结点之前使用git reset 或者git rebase\n严禁对不止一人交互的仓库使用git push —force\n\n上述三条注意事项都是为了避免对提交历史造成关键性影响，对提交历史的更改在多人协作中可能造成拉取和推送的冲突，而且还会影响到其他成员的工作。所以在多人开发中应该尽量通过创建新的提交来代替更改以往的提交。\n","categories":["技术笔记"],"tags":["git","github"]},{"title":"P1002-过河卒","url":"/2024/10/22/P1002-%E8%BF%87%E6%B2%B3%E5%8D%92/","content":"浴卒！\n\nP1002 [NOIP2002 普及组] 过河卒\n\n解法这一题目前了解到有两种解法，递归和动态规划(DP算法)。\n递归一开始我想到的方法是递归，通过递归罗列出卒走路的所有路线，再将成功的次数加起来。但是这个问题上，用递归所要经历的分支实在是太多了，不出意外地超时了。所以后续尝试将备忘录的思想和递归结合，设置一个二维数组当做备忘录，将走到一个点的路线数记录下来，这样以后再遇到需要这个点的路线数的情况，就不用再递归了，直去备忘录取数字就行。这样可以用空间换时间。最后证实是可行的。\n#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;# define ll long long// 递归函数，带备忘录ll move(int x, int y, int a, int b, int c, int d, std::vector&lt;std::vector&lt;ll&gt;&gt;&amp; memo) &#123;    // 如果当前位置与马的距离为 5，或超出了目标区域，或马挡住兵    if (((x - c) * (x - c) + (y - d) * (y - d)) == 5 || x &gt; a || y &gt; b || (x == c &amp;&amp; y == d)) &#123;        return 0;  // 这是错误的路线    &#125;        // 如果到达目标点    if (x == a &amp;&amp; y == b) &#123;        return 1;  // 成功找到一条路线    &#125;    // 检查备忘录，是否已经计算过这个点的结果    if (memo[x][y] != -1) &#123;        return memo[x][y];  // 如果计算过，直接返回结果    &#125;    // 计算从 (x, y) 到 (a, b) 的所有可能路线：向下走和向右走    ll right = move(x, y + 1, a, b, c, d, memo);  // 向右走    ll down = move(x + 1, y, a, b, c, d, memo);   // 向下走    // 存储结果到备忘录中    memo[x][y] = right + down;    // 返回当前点的路径总数    return memo[x][y];&#125;int main() &#123;    int a, b, c, d;    std::cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;    // 创建备忘录，初始化为 -1，表示所有位置尚未计算    std::vector&lt;std::vector&lt;ll&gt;&gt; memo(a + 1, std::vector&lt;ll&gt;(b + 1, -1));    // 计算从 (0,0) 到 (a,b) 的路线总数    ll result = move(0, 0, a, b, c, d, memo);    // 输出结果    std::cout &lt;&lt; result &lt;&lt; std::endl;    return 0;&#125;\n需要注意的是，存储路线数的变量一定要用long long类型，因为在第三个测试节点，路线数已经到了11位大小，超出了int和long(之前没考虑到这点，浪费了很多时间)。\nDP算法后面看了一下题目标签了解了一下DP算法，发现用dp确实简便了许多，递归还要套一层又一层，可能会栈溢出，DP算法只要一个双层循环就行了，方便了许多，以后遇到类似问题可以多一种思路。#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define ll long longusing namespace std;const int fx[] = &#123;0, -2, -1, 1, 2, 2, 1, -1, -2&#125;;const int fy[] = &#123;0, 1, 2, 2, 1, -1, -2, -2, -1&#125;;//马可以走到的位置int bx, by, mx, my;ll f[40][40];bool s[40][40]; //判断这个点有没有马拦住int main()&#123;    cin&gt;&gt;bx&gt;&gt;by&gt;&gt;mx&gt;&gt;my;    bx += 1; by += 1; mx += 1; my += 1;    //坐标+1以防越界    f[1][0] = 1;//初始化    s[mx][my] = 1;//标记马的位置    for(int i = 1; i &lt;= 8; i++) s[mx + fx[i]][my + fy[i]] = 1;    for(int i = 1; i &lt;= bx; i++)&#123;        for(int j = 1; j &lt;= by; j++)&#123;            if(s[i][j]) continue; // 如果被马拦住就直接跳过            f[i][j] = f[i - 1][j] + f[i][j - 1];            //状态转移方程        &#125;    &#125;    cout&lt;&lt;f[bx][by]&lt;&lt;endl;    return 0;&#125;\n","categories":["算法题解"],"tags":["C++","DP算法","递归"]},{"title":"pip命令基础(包括虚拟环境的使用)","url":"/2024/10/14/pip%E5%91%BD%E4%BB%A4%E5%9F%BA%E7%A1%80/","content":"原来清华源可以永久换源。。。。。。？\n安装包pip install &lt;包名&gt;\n例如：pip install numpy指定版本：pip install numpy==1.21.0\n升级已安装的包pip install --upgrade &lt;包名&gt;\n升级pippython.exe -m pip install --upgrade pip\n如果你的电脑里面不止一个版本的python，记得把python.exe换成你这个项目用的那个版本的python的exe文件的绝对路径。如果绝对路径中有空格，就用双引号把路径框起来，在双引号前面加&amp; ，例如：&amp; &quot;D:\\Program Files\\Python\\3.8\\python.exe&quot; -m pip install --upgrade pip\n卸载包pip uninstall &lt;包名&gt;\n查看已安装的包列出当前环境中已安装的所有包：pip list如果想查看某个包的详细信息：pip show &lt;包名&gt;\n搜索包pip search &lt;关键词&gt;\n安装本地依赖如果你有一个项目的依赖文件 requirements.txt，可以通过以下命令批量安装所需的包：pip install -r requirements.txtrequirements.txt 文件里面包含了一行行的包名和版本号，pip 会按照文件中的内容逐一安装，例如，文件可能包含以下内容：numpy==1.21.2pandas==1.3.3matplotlib==3.4.3当你运行 pip install -r requirements.txt 时，pip 会自动安装这些列出的包及其指定版本。\n导出已安装的包可以将当前环境中的所有包导出到一个 requirements.txt 文件中，以便在其他环境中复现：pip freeze &gt; requirements.txt\n使用国内镜像源直接安装包在国内使用 pip 时，由于访问 PyPI 官方源速度较慢，可以使用国内镜像，例如清华源。使用时，可以指定源地址：pip install &lt;包名&gt; -i https://pypi.tuna.tsinghua.edu.cn/simple\n永久换源每次安装都要输入”-i https://pypi.tuna.tsinghua.edu.cn/simple&quot;会很不方便，可以选择永久换源，这样每次安装只要pip install就行：pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple\n恢复默认源如果你不想换源了，可以恢复默认源：pip config unset global.index-url\n检查过时的包你可以检查已安装的包是否有可用更新：pip list --outdated\n清除下载的缓存当包的安装出现问题时，可以尝试清除 pip 的缓存：pip cache purge\n检查依赖冲突使用以下命令检查安装包时是否有依赖冲突：pip check\n显示帮助pip --help\n虚拟环境虚拟环境的优势直接在命令行输入pip install &lt;包名&gt;会导致包安装到系统Python的全局site-packages目录，这在运行简单程序的时候没有什么问题，但是在程序比较复杂的时候会出现若干问题，比如你电脑安装过多个python，但一般情况，哪怕你把你安装过的python的路径都加到过系统环境路径，系统默认python也只会默认为一个(一般是你最后安装的python版本)你可以输入：python --version查看成为系统默认python的那个版本当你希望用3.8版本的python运行一个程序，而且你的IDE确实把python3.8作为了解释器，而你的系统默认python是3.9,那问题就来了，哪怕你把pip install敲一万遍，包也不会被安装进python3.8的全局site-packages目录，程序自然也别想跑通，因为包安装的位置和你实际用到的解释器没用关系。此外，就算你要用的就是3.9，而且确实安装对了，但是大型项目用到的包与包之间发生版本冲突是经常的，不同程序共用一个全局site-packages，那冲突发生的可能性就更大了，你应该不希望隔一天运行同一个程序还要因为中间调过另一个程序而导致之前的程序因为包的版本冲突而突然跑不起来。所以，我们需要把不同程序用到的包环境隔离开来，这需要用到虚拟环境。虚拟环境不仅可以隔离环境防止冲突，而且创建虚拟环境时规定了python的版本，后续运行程序的时候只要在虚拟环境中直接用python 文件名.py的命令就可以使用你希望的python版本解释程序，不用每次运行程序都为了用和系统python不一样的版本而输入一遍那个版本python执行程序的绝对路径。同时，虚拟环境下pip install安装的包就在项目目录下，方便查找和管理。\n创建虚拟环境在项目根目录输入命令：python -m venv envname当然，为了避免不必要的冲突可能，如果你要用到的python和系统默认python版本不一样，建议用下述命令：path\\to\\python.exe -m venv envnamepath\\to\\python.exe 是你用的那个版本的python的可执行文件的绝对路径(windows以外的系统可能不叫exe)envname是你创建的虚拟环境的名字，你可以随便换成其他名字，懒得取名可以直接换成.venv 例如：python -m venv .venvpython.exe的绝对路径中可能有空格，那就需要把绝对路径用&amp;””框起来，例如：&amp; &quot;D:\\Program Files\\Python\\3.8\\python.exe&quot; -m venv .venv可以创建一个名叫.venv ，版本为python3.8的虚拟环境\n激活进入虚拟环境创建完毕以后，你输入创建命令的目录下会多一个叫.venv的文件夹(和你取的名字一样)，这就是你创建的虚拟环境。打开这个文件夹，里面会有一个叫Scripts的文件(MacOS那里是bin文件)，打开这个文件夹，里面有个叫activate的文件，执行这个文件就能激活进入虚拟环境我们回到之前创建虚拟环境的那一级目录，在那里输入命令:.\\envname/Scripts/activate\t//Windowssource myenv/bin/activate\t//Linux、Macosenvname 是你取的虚拟环境的名字例如你取的名字是.venv ,那激活命令就是.\\.venv/Scripts/activate\t//Windowssource .venv/bin/activate\t//Linux、Macos激活以后，每一行命令的路径前都会多一个(虚拟环境名)的前缀，比如：前面有个黄色括号就是成功了，在这个虚拟环境下pip install的所有包都会下进.venv/Lib/site-packages。同时在这个虚拟环境下用python 程序名.py运行程序，用到的解释器就是你创建虚拟环境时用的那版的python。如果你用的IDE，比如vscode，记得把解释器换成虚拟环境的解释器(vscode会直接提示你换)，虚拟环境的解释器就在envname/Scripts/ 目录下。之后每打开项目时把激活虚拟环境的命令输入一遍就行了。\n","categories":["技术笔记"],"tags":["pip","Python"]},{"title":"将python程序打包成可执行的文件","url":"/2024/10/13/%E5%B0%86python%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85%E6%88%90%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%9A%84%E6%96%87%E4%BB%B6/","content":"把赤石的机会分享给他人罢了。作为一种解释型语言而非编译型语言，python并不像C++那样可以直接生成可执行文件。这意味着一个python程序想在另一台电脑上跑就必须在另一台电脑装python解释器。但生活经验告诉你，你用的应用都有可执行文件（windows中是exe），它们当中大概率有python编译的部分，但它们为什么可以有可执行文件？事实上，python也不是完全不能有可执行文件，但是要通过工具打包，PyInstaller就是一种方法。PyInstaller 是一个将 Python 脚本打包为独立可执行文件的工具，支持 Windows、macOS 和 Linux 系统。以下是使用 PyInstaller 的步骤：\n安装 PyInstaller在终端输入命令：pip install pyinstaller\n打包 Python 脚本假设你有一个 Python 文件 app.py，在解释器里你通过运行它来运行整个项目，你可以通过以下方法打包它：\n直接打包pyinstaller app.py\n然后你会看到，PyInstaller 会生成一个 dist 目录，其中包含一个 app 文件夹，这个文件夹内就是打包后的可执行文件。此外，还会生成 build 目录（构建过程中的临时文件）和 .spec 文件（配置文件）。\n生成单个可执行文件pyinstaller --onefile app.py\n这样一来，dist 目录下就只有app的可执行文件了，没有了其他的依赖项，但是这样一来，可执行文件的大小会比原来大很多，之前的依赖项、解释器、第三方库都被打包进了可执行文件。\n指定图标pyinstaller --onefile --icon=myicon.ico app.py\nmyicon.ico是你的图标文件，它最好和app.py放在同一级目录，ico文件可以用图片文件在aconvert自行制作。指定图标之后，你的可执行文件的图标就不再是这样的默认可执行文件图标了\n不显示控制台窗口（适用于 GUI 应用程序）pyinstaller --onefile --windowed app.py\n这样一来，启动可执行文件就不会启动终端了。\n打包外部资源（如图片、音频等）# Windowspyinstaller --add-data &quot;path_to_file;target_folder&quot; app.py# macOS/Linuxpyinstaller --add-data &quot;path_to_file:target_folder&quot; app.py\n比如你的文件结构长这样：project_folder/│├── app.py                        # 主程序├── resources/                    # 顶层文件夹│   ├── images/│   │   └── assets/│   │       └── logo.png          # 需要打包的图片文件│   └── config/│       └── config.yaml           # 需要打包的配置文件此时，logo.png 被放在 resources/images/assets/ 文件夹下，而 config.yaml 位于 resources/config/ 文件夹中。那么，此时，windows命令就是：pyinstaller --onefile \\    --add-data &quot;resources/config/config.yaml;resources/config&quot; \\    --add-data &quot;resources/images/assets/logo.png;resources/images/assets&quot; app.py\n生成后的文件打包完成后，你会在 dist 文件夹中找到打包好的可执行文件。如果你使用了 —onefile 选项，它会生成一个独立的 .exe 文件（Windows）或其他可执行文件。如果没有使用 —onefile，则会生成一个包含多个文件的目录。\n使用 .spec 文件PyInstaller 会生成一个 .spec 文件，其中保存了打包时的配置信息。如果你想修改打包过程中的某些细节，可以编辑这个 .spec 文件，然后使用以下命令重新打包：pyinstaller app.spec\n其他上述打包 Python 脚本的各种选项可以叠加，比如假设你想要打包一个 GUI 程序，并生成一个单独的可执行文件，同时使用自定义图标，可以运行：pyinstaller --onefile --windowed --icon=myicon.ico app.py\n","categories":["技术笔记"],"tags":["Python","pyinstaller"]},{"title":"在Python中调用C++函数","url":"/2024/10/11/%E5%9C%A8Python%E4%B8%AD%E8%B0%83%E7%94%A8C-%E5%87%BD%E6%95%B0/","content":"我嘞个语言版奇美拉Python 作为一种解释型语言，虽然易于编写和维护，但在执行速度上可能不如 C++ 这样的编译型语言。C++ 提供了高度优化的性能，尤其是在计算密集型任务中。有时候，你可能已经有大量用 C++ 编写的现有代码或库，重新用 Python 实现这些功能费时费力。你或许想过通过调用 C++ 代码来复用这些现有的模块和算法。\n\n要实现 C++ 和 Python 跨语言编程，可以使用 Python 的 ctypes 或 pybind11 来调用 C++ 代码。下面介绍两种方式：\n方法一：使用 ctypesctypes 是 Python 的一个标准库，可以让你调用 C++ 动态链接库（如 .dll）。\n编写 C++ 代码并生成动态链接库编写 C++ 代码并编译成动态库（.dll），例如：// example.cppextern &quot;C&quot; &#123;    int add(int a, int b) &#123;        return a + b;    &#125;    int sub(int a, int b) &#123;        return a - b;    &#125;&#125;编译该文件生成 .dll，例如使用 g++:g++ -shared -o example.dll -fPIC example.cppC++代码中使用了extern “C”是将C++转换成C风格。C++ 编译器会对函数名进行一种称为 “name mangling” 的过程，即编译器会根据函数的名称、参数类型、返回值类型等信息生成一个唯一的标识符。这样做是为了支持函数重载（不同参数的同名函数），但它也导致编译后的函数名和源码中的名称不一致。例如，C++ 中以下两个函数可能会在编译后被重整为不同的名字：int add(int a, int b);        // 可能被重整为 _Z3addiifloat add(float a, float b);  // 可能被重整为 _Z3addff这个重整过程使得 Python 的 ctypes 无法找到正确的函数名称。\n在 Python 中使用 ctypes 调用 C++ 函数在 Python 中调用该动态库：import ctypes# 加载 C++ 动态链接库example = ctypes.CDLL(&#x27;./example.dll&#x27;)# 调用 C++ 函数result = example.add(5, 3)print(result)  # 输出 8result = example.sub(5, 3)print(result)  # 输出 2于是我们就在Python中调用了C++的函数。但使用 ctypes 调用 C++ 类是比较复杂的，因为 ctypes 主要用于处理 C 语言风格的函数调用，而 C++ 类的特性（如构造函数、析构函数、继承、多态等）无法直接通过 ctypes 调用。于是我们需要一种泛用性更高的方法——pybind11。\n方法二：使用 pybind11请确定你可以使用Visual Studio编译器！\n \n我之前用的MinGW的编译器一直生成失败，换成visual studio工具链的编译器就立马能生成了，应该是因为MinGW 的一些版本在处理 C++11 的多线程支持时存在兼容性问题。\n\npybind11 是一个轻量级的库，专门用于将 C++ 和 Python 绑定。\n安装cmake进入cmake官网走下载流程就行。一般情况会C++的电脑里面都有cmake，除非你的电脑刚好是windows，而且电脑里刚好有visual studio。\n下载pybind11的库在github中搜索pybind11，将仓库里面的内容下载到本地。如果下载了git，可以直接用git clone https://github.com/pybind/pybind11.git将文件拷贝到本地。\n将pybind11库放进项目文件夹官方文档中推荐将pybind11库放进一个叫extern的文件夹里面。我们进入要使用pybind的项目的根目录，在里面新建一个叫extern的文件夹，把pybind11库移动进去。\n编辑CmakeList文件打开任意一个集成开发环境(比如vscode)，在根目录创建一个CmakeLists.txt文件。cmake_minimum_required(VERSION 3.23)project(example)  # 设置项目名称set(CMAKE_CXX_STANDARD 17)set(CMAKE_CXX_STANDARD_REQUIRED ON)set(CMAKE_CXX_EXTENSIONS OFF)set(PYTHON_EXECUTABLE &quot;D:/....../Python/python.exe&quot;)set(PYTHON_LIBRARY &quot;D:/....../Python/libs/python.lib&quot;)set(PYTHON_INCLUDE_DIR &quot;D:/....../Python/include&quot;)add_subdirectory(extern/pybind11)pybind11_add_module(example example.cpp)将上述脚本输入CmakeLists.txt文件。其中pybind11_add_module()中的Example代表等会生成的连接库文件的名字(可以换成其他的名字)，example.cpp则是包含要调用函数或者类的cpp文件，如果有多个cpp文件，就将多个cpp文件都加上去，用空格” “隔开。set(PYTHON…………..)那三行找到你电脑里面的python文件，将exe文件、lib文件、include文件夹的绝对地址换进去。比如你用的python3.8，那第二行就要找的是python38.lib的绝对地址，以此类推，但注意的是这里选择的python和你后面解释python程序时用的python解释器必须是同一个python(比如你现在填的3.8后面就一定要用3.8去解释)\n编写要调用的cpp文件C++函数的例子//example.cpp#include &lt;pybind11/pybind11.h&gt;namespace py = pybind11;int add(int i, int j)&#123;    return i + j;&#125;PYBIND11_MODULE(example, m)&#123;    // 可选，说明这个模块是做什么的    m.doc() = &quot;pybind11 example plugin&quot;;    //def( &quot;给python调用方法名&quot;， &amp;实际操作的函数， &quot;函数功能说明&quot; ，py::arg()初始化). 其中函数功能说明和初始化为可选    m.def(&quot;add&quot;, &amp;add, &quot;A function which adds two numbers&quot;, py::arg(&quot;i&quot;)=1, py::arg(&quot;j&quot;)=2);&#125;\nC++类的例子//example.cpp#include &lt;pybind11/pybind11.h&gt;#include &lt;iostream&gt;namespace py = pybind11;// 绑定一个类class SomeClass&#123;public:    SomeClass(float scale_) : scale(scale_) &#123;&#125;;    float multiply(float input)    &#123;        float res = input * scale;        std::cout &lt;&lt; &quot;res:&quot; &lt;&lt; res &lt;&lt; std::endl;        return res;    &#125;private:    float scale;&#125;;PYBIND11_MODULE(example, m)&#123;    py::class_&lt;SomeClass&gt;(m, &quot;SomeClass&quot;)       // 绑定一个类        .def(&quot;multiply&quot;, &amp;SomeClass::multiply) // 绑定一个成员函数        .def(py::init&lt;float&gt;());                // 绑定一个构造函数&#125;\n通过cmake构建动态连接库文件在根目录创建一个名为build的文件夹，进入文件夹那级目录，在终端依次输入：cmake ..cmake --build .(当然如果你装了和cmake有关的插件(Cmake和Cmake Tools)也可以用神秘小按钮代替命令 )\n(Cmake为CmakeLists.txt增加高亮等功能，Cmake Tools在下方增加了方便构建的按钮 )这时你的build文件夹里出现了很多文件，在里面找到Debug(也可能是Release)文件夹，在其中找到一个.pyd(或者.so)结尾的文件，那就是动态链接库文件，后续会用到。\n编写python文件，并引入C++写的模块引入函数情况的例子# example.pyimport sys# 添加生成的模块路径sys.path.append(&quot;D:/....../your_project/build/Debug&quot;)# 或者sys.path.append(&quot;D:/....../your_project/build/Release&quot;)import example as hw  # 测试调用print(hw.add(1, 2))     //result：3\n引入类情况的例子# example.pyimport sys# 添加生成的模块路径sys.path.append(&quot;D:/....../your_project/build/Debug&quot;)# 或者sys.path.append(&quot;D:/....../your_project/build/Release&quot;)import example as epa = ep.SomeClass(3.0)a.multiply(2.0)print(a)\nsys.path.append()将包含 .pyd (或者.so)文件的目录添加到 sys.path 中，便于模块导入。\n导入以后就可以直接运行了，切记，要用和之前set(PYTHON…………..)里面填的一样的python解释器去运行，不然不一定会成功，如果你的集成开发环境安装了run code这样的插件，也记得换成python解释器，run code跑不了一点。\n","categories":["技术笔记"],"tags":["C++","Python","Ctype","Pybind"]},{"title":"在Arknights 主题中通过valine配置评论区","url":"/2024/10/08/%E5%9C%A8Arknights-%E4%B8%BB%E9%A2%98%E4%B8%AD%E9%80%9A%E8%BF%87valine%E9%85%8D%E7%BD%AE%E8%AF%84%E8%AE%BA%E5%8C%BA/","content":"最初，神没有将头像赐予世人……\n安装valine环境输入命令npm install valine --save\n获取AppID、AppKey和server_urlAppID、AppKey和server_url通过后端服务平台LeanCloud获取，记得最好是国际版（问就是国内版没配成功。。。）点击左上角创建应用取个名字，然后选开发版应用创建好以后，进入刚刚创建的应用，选择左边的设置&gt;应用凭证，然后就能看到你的AppID、AppKey和server_url了。注意，在应用凭证这个界面里，server_url对应的是REST API 服务器地址\n配置文件复制上述的三串东西，在你对应主题的_config文件里把地址黏贴在valine对应位置valine:  enable: true  app_id:   app_key:   server_url:    avatar: &#x27;gravatar&#x27; # (&#x27;&#x27;/mp/identicon/monsterid/wavatar/robohash/retro/hide)  avatar_cdn: &#x27;https://dn-qiniu-avatar.qbox.me/avatar/&#x27; # 自定义 avatar cdn\n安全域名在之前LeanCloud的设置栏下的安全中心中，在Web 安全域名框里填下你的博客网址。之后，评论区就配置好了\n管理评论在数据存储-&gt;结构化数据-&gt;Comment里面可以看到你博客下发送的评论，你也可以根据需求删除或对这些评论进行其他操作。\n自定义头像在gravatar用邮箱注册一个账户并设置头像，以后如果在valine评论区配置中的avatar:参数为‘gravatar’的博客中评论，头像就会变成你在gravatar设置的头像。头像设置完有个缓存期，期间评论没有头像不必心急。\n","categories":["心得分享"],"tags":["hexo","valine"]},{"title":"单纯形法算法详解","url":"/2024/12/10/%E5%8D%95%E7%BA%AF%E5%BD%A2%E6%B3%95%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/","content":"用处单纯形法是一种线性规划迭代算法，能够在有限步内找到线性规划问题的最优解（如果解存在的话）。\n算法步骤以下述线性规划问题为例：\n\nmaxz = 2x_{1} + 3x_{2}\n\\\\s.t.\n\\left\\{\\begin{matrix}\n  x_{1} + 2x_{2} & \\le & 8\\\\\n  4x_{1} & \\le & 16\\\\\n  4x_{2} & \\le & 12\\\\\n  x_{1} , x_{2} & \\ge & 0\n\\end{matrix}\\right.其中，第一行是线性目标，大括号里面的内容是约束条件\n化为标准型\n确定线性目标是求的max问题，如果是min问题，则将等号两边都乘以-1，从而转变为max问题。\n\n确定最后一行的每一个x都大于等于0，如果有小于等于的x，则将那个x变成两个大于等于0的数的相减。\n\n\n​    例如：如果x_{1}\\le0，则x_{1}可以化成x_{1}^{'}-x_{1}^{''}。\n​    转换以后将最后一行变成x_{1}^{'}\\ge 0, x_{1}^{''}\\ge 0, x_{2}\\ge 0，将最后一行以外约束条件里面的x_{1}也变成x_{1}^{'}-x_{1}^{''}。\n\n确定最后一行以外的约束条件都是$\\le$，如果有$\\ge$，则不等号两边乘以-1从而变号为$\\le$。\n\n单纯形法硬性要求后续约束条件化成的矩阵中存在单位矩阵，所以对于没有单位矩阵的情况，需要手动凑单位矩阵。除最后一行以外的约束条件有几行，就增加几个额外的大于等于0的变量用于凑单位矩阵。\n例如：上述线性规划问题凑完以后的结果为\n\nmaxz = 2x_{1} + 3x_{2} + 0x_{3} + 0x_{4} + 0x_{5}\n\\\\s.t.\n\\left\\{\\begin{matrix}\n  x_{1} + 2x_{2} + x_{3} & = & 8\\\\\n  4x_{1} + x_{4} & = & 16\\\\\n  4x_{2} + x_{5} & = & 12\\\\\n  x_{1}, x_{2}, x_{3}, x_{4}, x_{5} & \\ge & 0\n\\end{matrix}\\right.\n\n​    增加了三个新的变量x_{3}, x_{4}, x_{5},这样不仅凑出了单位矩阵(后续解释)，而且还去掉了不等号。\n\n将其余每一行缺失的变量都用0补上，得到最终化为标准型的结果为：\nmaxz = 2x_{1} + 3x_{2} + 0x_{3} + 0x_{4} + 0x_{5}\n\\\\s.t.\n\\left\\{\\begin{matrix}\n  1x_{1} + 2x_{2} + 1x_{3} + 0x_{4} + 0x_{5} & = & 8\\\\\n  4x_{1} + 0x_{2} + 0x_{3} + 1x_{4} + 0x_{5} & = & 16\\\\\n  0x_{1} + 4x_{2} + 0x_{3} + 0x_{4} + 1x_{5} & = & 12\\\\\n  x_{1}, x_{2}, x_{3}, x_{4}, x_{5} & \\ge & 0\n\\end{matrix}\\right.\n\n列出初始单纯形表\n\n  表头(左对齐)\n  表头(居中)\n  表头(右对齐)\n\n\n  行1，列1\n  行1，列2\n  行1，列3\n\n\n  合并行单元格\n  行2，列3\n\n\n  合并列单元格\n  行3，列2\n  行3，列3\n\n\n  行4，列2\n  行4，列3\n\n\n\n","categories":["学习笔记"],"tags":["线性规划","运筹与优化"]},{"title":"用Matlab实现高斯消元法","url":"/2024/11/19/%E7%94%A8Matlab%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E6%B3%95/","content":"温柔的是武藏，不是高斯。\n函数实现function x = gauss_elim(A, b)    % 获取矩阵 A 的维度    [n, ~] = size(A);        % 扩展矩阵 A 和向量 b 组成增广矩阵 [A|b]    Ab = [A b];        % 高斯消元过程    for i = 1:n        % 选取主元素（行交换）        [~, maxRow] = max(abs(Ab(i:n, i))); % 找到第 i 列的最大元素        maxRow = maxRow + i - 1; % 修正为全矩阵的行号        if i ~= maxRow            % 交换行            Ab([i, maxRow], :) = Ab([maxRow, i], :);        end                % 消元过程，消去主元下方的元素        for j = i+1:n            % 计算系数            factor = Ab(j, i) / Ab(i, i);            % 更新该行            Ab(j, :) = Ab(j, :) - factor * Ab(i, :);        end    end        % 回代求解    x = zeros(n, 1); % 初始化解向量    for i = n:-1:1        x(i) = (Ab(i, end) - Ab(i, 1:n) * x) / Ab(i, i);    endend","categories":["学习笔记"],"tags":["运筹与优化","高斯消元法","Matlab"]},{"title":"无集成开发环境下运行程序","url":"/2024/10/14/%E6%97%A0%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%8B%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F/","content":"没用小寄巧罢了叠甲——本文没有推荐任何人放弃IDE\n本篇就是介绍一种可能性，一种不用集成开发环境直接纯终端敲命令行的可能性，可以装逼，没啥实用性。第一步：卸载vscode、CLion、PyCharm、VisualStudio(我就随便说说，你别真卸了)\n——————————————————————正常步骤—————————————————————— \nC++版环境安装MingGW(C++/C的编译器)如果你之前用VisualStudio这样的IDE不需要编译器，是因为微软给你把编译器配好了，如果你还用过vscode、CLion就会发现，编译器的配置选项可以选VisualStudio的自带编译器\n创建文件随便创建一个文件夹往里面新建几个文件，注意后缀用令人熟悉的cpp和h，像这样—\n编写文件用一个文本编辑器(比如你的记事本)打开这些文件，然后简单编写一下：// main.cpp#include&lt;iostream&gt;#include&quot;example.h&quot;int main()&#123;\tint a = 4, b = 8;\texample Ex(a,b);\tstd::cout&lt;&lt;Ex.add();&#125;// example.h#include&lt;iostream&gt;class example&#123;public:\texample(int a,int b);\tint add();private:\tint A;\tint B;&#125;;//example.cpp#include&quot;example.h&quot;example::example(int a,int b):A(a),B(b)&#123;\tstd::cout&lt;&lt;&quot;Hello,I am initialized&quot;&lt;&lt;std::endl;&#125;int example::add()&#123;\treturn A+B;&#125;\n编译程序用g++命令构建然后在放这三个文件的文件夹里面输入：g++ main.cpp example.cpp -o Exampleg++后面跟着的是项目里面所有cpp文件，用空格隔开。-o 后面是可执行文件的名字输入命令以后，在同一个文件夹里面，多了一个叫Example.exe的文件\n用cmake构建编写CmakeLists文件在根目录(放这三个文件的文件夹)创建一个叫CmakeLists.txt的文件，在里面写上例如：cmake_minimum_required(VERSION 3.28)project(Example)set(CMAKE_CXX_STANDARD 17)add_executable(Draft main.cpp example.cpp)这样的指令\n配置命令在根目录创建一个build文件夹，进入文件夹。你可以直接通过cmake ..配置项目，这样会以系统默认的生成器完成配置，如果你想要指定生成器(MinGW、VisualStudio、Ninja)和生成模式(Debug、Release),可以通过：cmake -G &quot;MinGW Makefiles&quot; -DCMAKE_BUILD_TYPE=Debug ..\t\t\t//指定MingGW生成器,并使用Debug模式cmake -G &quot;MinGW Makefiles&quot; -DCMAKE_BUILD_TYPE=Release ..\t\t//指定MingGW生成器,并使用Release模式cmake -G &quot;MinGW Makefiles&quot; -DCMAKE_BUILD_TYPE=RelWithDebInfo ..\t\t//指定MingGW生成器,并使用RelWithDebInfo模式cmake -G &quot;MinGW Makefiles&quot; -DCMAKE_BUILD_TYPE=MinSizeRel ..\t\t//指定MingGW生成器,并使用MinSizeRel模式cmake -G &quot;Ninja&quot; -DCMAKE_BUILD_TYPE=Debug ..\t\t\t\t//指定Ninja生成器,并使用Debug模式cmake -G &quot;Visual Studio 17 2022&quot; -A x64 ..\t\t\t\t//Visual Studio 的生成器不使用 CMAKE_BUILD_TYPE 变量，因为它们默认支持多种配置,可以在构建时指定配置等命令自定义生成方法(当然前提是你有安装过这些生成器，可以通过cmake —help命令查看你有哪些生成器)Generators下面的信息会告诉你你安装过哪些生成器。\n构建命令在build文件夹输入cmake --build .命令构建，如果你用的生成器是visual studio生成器，可以指定构建模式：cmake --build . --config Debug\t\t//Debug模式cmake --build . --config Release\t//Release模式\n构建完成以后，在build文件夹(VisualStudio生成器是Debug或者Release文件夹)里会出现一个可执行文件，说明程序编译成功了。\n请确定你的项目文件夹的路径里面没有中文！\n \ncmake压根就不认中文，有中文路径生成直接出错。\n执行程序用命令：.\\Example.exe运行可执行文件于是程序的结果执行了出来。\nPython版和前面C++一样，随便写点文件就行。然后创建一个虚拟环境，并将其激活。假如最后程序从app.py开始运行，只要在命令行输入：python app.py程序就可以执行了\n由此不难看出，运行一个程序需要的是编译器(python是需要解释器),而不是IDE，但IDE该用还是得用，IDE上的许多功能(高亮、自动补全、自动跳转、错误警告等…)可以大大提高编写的效率。\n","categories":["技术笔记"],"tags":["C++","Python"]},{"title":"通过aplayer为Arknights主题博客添加背景音乐","url":"/2024/10/11/%E9%80%9A%E8%BF%87aplayer%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E8%83%8C%E6%99%AF%E9%9F%B3%E4%B9%90/","content":"有的人花费一天时间只写出了一个充满违和感的按钮，而且代码位置同样很违和……笔者没学过前端，这种改法可行，但一定不是最好的，而且会有点破坏代码美感。\n \n安装aplayernpm install aplayer —save\n\n直接在博客根目录输入命令即可随后在_config.yml文件最底部加上aplayer:  preload: &#x27;metadata&#x27;  theme: &#x27;#e6d0b2&#x27;  autoplay: true  loop: &#x27;all&#x27;\n数据准备想要用aplayer在博客放音乐，需要三种文件：\n\nmp3文件(音频)\njpg/png文件(音乐封面)\nlrc文件(歌词)\n\n将准备好的文件放在如下位置your-blog/├── source/│   ├── assets/│   │   ├── music/│   │   │   └── yourmusic.mp3│   │   ├── images/│   │   │   └── yourmusic.jpg│   │   └── lrc/│   │       └── yourmusic.lrc├── themes/│   └── your-theme/│       └── layout/│           └── layout.pug├── _config.yml└── ...在source下创建相应的文件夹，并将文件放入。\n在某篇文章添加音乐&#123;% aplayerlist %&#125;&#123;    &quot;autoplay&quot;: true,    &quot;showlrc&quot;: 0,    &quot;mutex&quot;: true,    &quot;music&quot;: [        &#123;            &quot;title&quot;: &quot;music name&quot;,            &quot;author&quot;: &quot;author name&quot;,            &quot;url&quot;: &quot;/assets/music/music.mp3&quot;,            &quot;pic&quot;: &quot;/assets/images/music.jpg&quot;,            &quot;lrc&quot;: &quot;/assets/lrc/music.lrc&quot;        &#125;    ]&#125;&#123;% endaplayerlist %&#125;\n直接在想加音乐的文章中加入上述代码就会得到下面的效果（没有的话就刷新一下页面）：\n        \n\t\t\t  \n\t\t\t\t  var options = {\"narrow\":false,\"autoplay\":false,\"showlrc\":0,\"mutex\":true,\"music\":[{\"title\":\"ALLU\",\"author\":\"泽野弘之\",\"url\":\"https://raw.githubusercontent.com/fallingnight131/media_resource/blog/audio/ALLU.mp3\",\"pic\":\"https://raw.githubusercontent.com/fallingnight131/media_resource/blog/image/20250308032711151.png\"}]};\n\t\t\t\t  options.element = document.getElementById(\"aplayer-EtBOcizw\");\n\t\t\t\t  var ap = new APlayer(options);\n\t\t\t    window.aplayers || (window.aplayers = []);\n\t\t\t\t  window.aplayers.push(ap);\n\t\t\t  文章中多了一个音乐播放器，于是音乐添加成功了。\n如果不想占用本地空间，url、pic、lrc后面也可以换成网址，像这样：&#123;% aplayerlist %&#125;&#123;    &quot;autoplay&quot;: true,    &quot;showlrc&quot;: 0,    &quot;mutex&quot;: true,    &quot;music&quot;: [        &#123;            &quot;title&quot;: &quot;music name&quot;,            &quot;author&quot;: &quot;author name&quot;,            &quot;url&quot;: &quot;https://...&quot;,            &quot;pic&quot;: &quot;https://...&quot;,            &quot;lrc&quot;: &quot;https://...&quot;        &#125;    ]&#125;&#123;% endaplayerlist %&#125;\n这个三个网址是外部连接，可以通过将文件上传到七牛云的云存储空间以后生成。当然，如果觉得麻烦，也可以直接上传到github仓库。\n在Arknights主题中增加可自由关闭的全局背景音乐上面的方法是将音乐播放器添加在文章中，而现在我们要实现的是博客的全局背景音乐，笔者用的主题是Arknights主题，本身并没有提供aplayer的接口，所以我在界面中自己加了一个按钮来控制背景音乐的开关。接下来是具体步骤：\n找到layout.pug文件文件位置如下：your-blog/├── source/│   ├── assets/│   │   ├── music/│   │   │   └── yourmusic.mp3│   │   ├── images/│   │   │   └── yourmusic.jpg│   │   └── lrc/│   │       └── yourmusic.lrc├── themes/│   └── arknights/│       └── layout/│         └── includes/│           └── layout.pug├── _config.yml└── ...\n修改layout.pug文件直接把文件修改替换成如下：-  let pageTitle = page.title || config.subtitle || &#x27;&#x27;  if (is_post()) pageTitle = page.title  if (is_archive()) pageTitle = __(&#x27;menu.archive.plural&#x27;)  if (is_tag()) pageTitle = __(&#x27;menu.tag.plural&#x27;) + &#x27;: &#x27; + page.tag  if (is_category()) pageTitle = __(&#x27;menu.category.plural&#x27;) + &#x27;: &#x27; + page.category  if (is_month()) pageTitle += &#x27;: &#x27; + page.month + &#x27;/&#x27; + page.year  if (is_year()) pageTitle += &#x27;: &#x27; + page.year  if (pageTitle) pageTitle += &#x27; | &#x27;  pageTitle += config.title  const asideLogo = theme.aside.logo  const pjax = theme.pjax ? theme.pjax.enable : false  let searchConfig = null  if (theme.search !== undefined &amp;&amp; theme.search.enable === true) searchConfig = theme.search;  const configs = JSON.stringify(&#123;    root: config.root,    search: &#123;      preload: searchConfig.preload,      activeHolder: __(&#x27;search.activeHolder&#x27;),      blurHolder: __(&#x27;search.blurHolder&#x27;),      noResult: __(&#x27;search.noResult&#x27;)    &#125;,    code: &#123;      codeInfo: __(&#x27;code.codeInfo&#x27;),      copy: __(&#x27;code.copy&#x27;)    &#125;  &#125;)doctype htmlhtml(lang=config.language theme-mode=theme.color)  head    include ./meta-data.pug    link(rel=&quot;stylesheet&quot;, href=&quot;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css&quot;)    style.      #music-control &#123;        position: absolute; /* 使用绝对定位 */        bottom: 10px; /* 距离底部 10 像素 */        left: 30px; /* 距离左侧 30 像素 */        padding: 10px 20px;        font-size: 16px;        color: white;        background-color: rgba(0, 0, 0, 0.5);        border: 0.5px solid white;        border-radius: 0px;        cursor: pointer;        display: flex; /* 使用 flex 布局 */        align-items: center; /* 垂直居中 */        transition: background-color 0.3s ease, color 0.3s ease; /* 添加过渡效果 */      &#125;      #music-control:hover &#123;        background-color: rgba(90, 90, 90, 0.5);        color: #26a5e0;      &#125;  body    if pjax      .loading(style=&quot;opacity: 0;&quot;)        .loadingBar.left        .loadingBar.right    main      include ./header.pug      // 在这里添加控制按钮      button#music-control(type=&quot;button&quot;) 背景音乐-♪      article        if body          div!= body        else          block content        include ./bottom-btn.pug      include ./aside.pug    if theme.canvas_dust      canvas#canvas-dust    // 在这里添加 APlayer 播放器并隐藏它    #aplayer(style=&quot;display: none;&quot;)    script(src=&quot;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js&quot;)    script.      document.addEventListener(&#x27;DOMContentLoaded&#x27;, function () &#123;        const ap = new APlayer(&#123;          container: document.getElementById(&#x27;aplayer&#x27;),          autoplay: true,          loop: &#x27;all&#x27;,          preload: &#x27;metadata&#x27;,          theme: &#x27;#e6d0b2&#x27;,          audio: [            &#123;              name: &#x27;lifestream&#x27;,              artist: &#x27;arknights&#x27;,              url: &#x27;/assets/music/lifestream(machine).mp3&#x27;,              cover: &#x27;/assets/images/lifestream.jpg&#x27;,              lrc: &#x27;/assets/lrc/lifestream.lrc&#x27;            &#125;          ]        &#125;);        // 控制按钮的事件监听器        const controlButton = document.getElementById(&#x27;music-control&#x27;);        controlButton.addEventListener(&#x27;click&#x27;, function () &#123;          if (ap.audio.paused) &#123;            ap.play();          &#125; else &#123;            ap.pause();          &#125;        &#125;);      &#125;);\n修改完以后再通过hexo cleanhexo ghexo s重新构建博客，打开网页以后，界面的左下角始终有一个新的按钮，点击就能自由开关背景音乐。\n","categories":["心得分享"],"tags":["hexo","aplayer","html","BGM"]}]